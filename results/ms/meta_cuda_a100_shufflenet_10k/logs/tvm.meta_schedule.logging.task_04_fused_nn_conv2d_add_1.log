2024-04-28 19:50:49 [INFO] [task_scheduler.cc:160] Initializing Task #4: "fused_nn_conv2d_add_1"
2024-04-28 19:50:49 [INFO] [task_scheduler.cc:35] 
# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        PaddedInput = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)))
        DepthwiseConv2d = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)))
        for i0, i1, i2, i3 in T.grid(T.int64(1), T.int64(116), T.int64(16), T.int64(16)):
            with T.block("PaddedInput"):
                v_i0, v_i1, v_i2, v_i3 = T.axis.remap("SSSS", [i0, i1, i2, i3])
                T.reads(p0[v_i0, v_i1, v_i2 - T.int64(1), v_i3 - T.int64(1)])
                T.writes(PaddedInput[v_i0, v_i1, v_i2, v_i3])
                PaddedInput[v_i0, v_i1, v_i2, v_i3] = T.if_then_else(T.int64(1) <= v_i2 and v_i2 < T.int64(15) and T.int64(1) <= v_i3 and v_i3 < T.int64(15), p0[v_i0, v_i1, v_i2 - T.int64(1), v_i3 - T.int64(1)], T.float32(0))
        for b, c, i, j, di, dj in T.grid(T.int64(1), T.int64(116), T.int64(14), T.int64(14), T.int64(3), T.int64(3)):
            with T.block("DepthwiseConv2d"):
                v_b, v_c, v_i, v_j, v_di, v_dj = T.axis.remap("SSSSRR", [b, c, i, j, di, dj])
                T.reads(PaddedInput[v_b, v_c, v_i + v_di, v_j + v_dj], p1[v_c, T.int64(0), v_di, v_dj])
                T.writes(DepthwiseConv2d[v_b, v_c, v_i, v_j])
                with T.init():
                    DepthwiseConv2d[v_b, v_c, v_i, v_j] = T.float32(0)
                DepthwiseConv2d[v_b, v_c, v_i, v_j] = DepthwiseConv2d[v_b, v_c, v_i, v_j] + PaddedInput[v_b, v_c, v_i + v_di, v_j + v_dj] * p1[v_c, T.int64(0), v_di, v_dj]
        for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(116), T.int64(14), T.int64(14)):
            with T.block("T_add"):
                v_ax0, v_ax1, v_ax2, v_ax3 = T.axis.remap("SSSS", [ax0, ax1, ax2, ax3])
                T.reads(DepthwiseConv2d[v_ax0, v_ax1, v_ax2, v_ax3], p2[v_ax0, v_ax1, T.int64(0), T.int64(0)])
                T.writes(T_add[v_ax0, v_ax1, v_ax2, v_ax3])
                T_add[v_ax0, v_ax1, v_ax2, v_ax3] = DepthwiseConv2d[v_ax0, v_ax1, v_ax2, v_ax3] + p2[v_ax0, v_ax1, T.int64(0), T.int64(0)]
2024-04-28 19:50:49 [INFO] [task_scheduler.cc:164] Total 3 design space(s) generated
2024-04-28 19:50:49 [INFO] [task_scheduler.cc:170] Design space #0:
# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        with T.block("root"):
            T.reads()
            T.writes()
            T.block_attr({"meta_schedule.unroll_explicit": 1024})
            DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
            PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
            p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
            for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(2), thread="blockIdx.x"):
                for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(49), thread="vthread.x"):
                    for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(2), thread="threadIdx.x"):
                        for di_0, dj_0 in T.grid(T.int64(3), T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused in range(T.int64(12992)):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), ax0_ax1_ax2_ax3_fused // T.int64(112))
                                    v2 = T.axis.spatial(T.int64(16), di_0 + b_0_c_0_i_0_j_0_fused * T.int64(7) + ax0_ax1_ax2_ax3_fused % T.int64(112) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), ax0_ax1_ax2_ax3_fused % T.int64(16))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    T.block_attr({"meta_schedule.cooperative_fetch": 3})
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                            for ax0_ax1_ax2_ax3_fused in range(T.int64(348)):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), ax0_ax1_ax2_ax3_fused // T.int64(3))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), di_0)
                                    v3 = T.axis.spatial(T.int64(3), ax0_ax1_ax2_ax3_fused % T.int64(3))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    T.block_attr({"meta_schedule.cooperative_fetch": 1})
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                            for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(58), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                                with T.block("DepthwiseConv2d"):
                                    v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                    v_c = T.axis.spatial(T.int64(116), b_2_c_2_i_2_j_2_fused * T.int64(58) + c_3 + c_4)
                                    v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused * T.int64(7) + b_1_c_1_i_1_j_1_fused // T.int64(7) + i_3 + i_4)
                                    v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                    v_di = T.axis.reduce(T.int64(3), di_0 + di_1 + di_2)
                                    v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                    T.reads(PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                    T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                    T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                    with T.init():
                                        DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                                    DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                        for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(58), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_local"):
                                v0 = T.axis.spatial(T.int64(1), ax0)
                                v1 = T.axis.spatial(T.int64(116), b_2_c_2_i_2_j_2_fused * T.int64(58) + ax1)
                                v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused * T.int64(7) + b_1_c_1_i_1_j_1_fused // T.int64(7) + ax2)
                                v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(7) * T.int64(2) + ax3)
                                T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                                T.writes(T_add[v0, v1, v2, v3])
                                T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[1, 1, 2, 58, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 7, 1, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 7, 1, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
2024-04-28 19:50:49 [INFO] [task_scheduler.cc:170] Design space #1:
# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        with T.block("root"):
            T.reads()
            T.writes()
            T.block_attr({"meta_schedule.unroll_explicit": 0})
            DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
            PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
            p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
            for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(2), thread="blockIdx.x"):
                for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(49), thread="vthread.x"):
                    for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(2), thread="threadIdx.x"):
                        for di_0_dj_0_fused in T.serial(T.int64(3), annotations={"software_pipeline_async_stages": [0], "software_pipeline_order": [0, 1, 2], "software_pipeline_stage": [0, 0, 2]}):
                            for ax0_ax1_ax2_ax3_fused in range(T.int64(12992)):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), ax0_ax1_ax2_ax3_fused // T.int64(112))
                                    v2 = T.axis.spatial(T.int64(16), di_0_dj_0_fused + b_0_c_0_i_0_j_0_fused * T.int64(7) + ax0_ax1_ax2_ax3_fused % T.int64(112) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), ax0_ax1_ax2_ax3_fused % T.int64(16))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    T.block_attr({"meta_schedule.cooperative_fetch": 3})
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                            for ax0_ax1_ax2_ax3_fused in range(T.int64(348)):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), ax0_ax1_ax2_ax3_fused // T.int64(3))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), di_0_dj_0_fused)
                                    v3 = T.axis.spatial(T.int64(3), ax0_ax1_ax2_ax3_fused % T.int64(3))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    T.block_attr({"meta_schedule.cooperative_fetch": 1})
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                            for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(58), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                                with T.block("DepthwiseConv2d"):
                                    v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                    v_c = T.axis.spatial(T.int64(116), b_2_c_2_i_2_j_2_fused * T.int64(58) + c_3 + c_4)
                                    v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused * T.int64(7) + b_1_c_1_i_1_j_1_fused // T.int64(7) + i_3 + i_4)
                                    v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                    v_di = T.axis.reduce(T.int64(3), di_0_dj_0_fused + di_1 + di_2)
                                    v_dj = T.axis.reduce(T.int64(3), dj_1 + dj_2)
                                    T.reads(PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                    T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                    T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                    with T.init():
                                        DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                                    DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                        for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(58), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_local"):
                                v0 = T.axis.spatial(T.int64(1), ax0)
                                v1 = T.axis.spatial(T.int64(116), b_2_c_2_i_2_j_2_fused * T.int64(58) + ax1)
                                v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused * T.int64(7) + b_1_c_1_i_1_j_1_fused // T.int64(7) + ax2)
                                v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(7) * T.int64(2) + ax3)
                                T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                                T.writes(T_add[v0, v1, v2, v3])
                                T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[1, 1, 2, 58, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 7, 1, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 7, 1, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
l90 = sch.fuse(l53, l59, preserve_unit_iters=True)
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_stage", ann_val=[0, 0, 2])
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_order", ann_val=[0, 1, 2])
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_async_stages", ann_val=[0])
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v91 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v91)
2024-04-28 19:50:49 [INFO] [task_scheduler.cc:170] Design space #2:
# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        with T.block("root"):
            T.reads()
            T.writes()
            T.block_attr({"meta_schedule.unroll_explicit": 512})
            DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
            PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
            p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
            for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(2), thread="blockIdx.x"):
                for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(49), thread="vthread.x"):
                    for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(2), thread="threadIdx.x"):
                        for di_0_dj_0_fused in T.serial(T.int64(3), annotations={"software_pipeline_async_stages": [0], "software_pipeline_order": [0, 1, 2], "software_pipeline_stage": [0, 0, 3]}):
                            for ax0_ax1_ax2_ax3_fused in range(T.int64(12992)):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), ax0_ax1_ax2_ax3_fused // T.int64(112))
                                    v2 = T.axis.spatial(T.int64(16), di_0_dj_0_fused + b_0_c_0_i_0_j_0_fused * T.int64(7) + ax0_ax1_ax2_ax3_fused % T.int64(112) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), ax0_ax1_ax2_ax3_fused % T.int64(16))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    T.block_attr({"meta_schedule.cooperative_fetch": 3})
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                            for ax0_ax1_ax2_ax3_fused in range(T.int64(348)):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), ax0_ax1_ax2_ax3_fused // T.int64(3))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), di_0_dj_0_fused)
                                    v3 = T.axis.spatial(T.int64(3), ax0_ax1_ax2_ax3_fused % T.int64(3))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    T.block_attr({"meta_schedule.cooperative_fetch": 1})
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                            for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(58), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                                with T.block("DepthwiseConv2d"):
                                    v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                    v_c = T.axis.spatial(T.int64(116), b_2_c_2_i_2_j_2_fused * T.int64(58) + c_3 + c_4)
                                    v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused * T.int64(7) + b_1_c_1_i_1_j_1_fused // T.int64(7) + i_3 + i_4)
                                    v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                    v_di = T.axis.reduce(T.int64(3), di_0_dj_0_fused + di_1 + di_2)
                                    v_dj = T.axis.reduce(T.int64(3), dj_1 + dj_2)
                                    T.reads(PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                    T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                    T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                    with T.init():
                                        DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                                    DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                        for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(58), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_local"):
                                v0 = T.axis.spatial(T.int64(1), ax0)
                                v1 = T.axis.spatial(T.int64(116), b_2_c_2_i_2_j_2_fused * T.int64(58) + ax1)
                                v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused * T.int64(7) + b_1_c_1_i_1_j_1_fused // T.int64(7) + ax2)
                                v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(7) * T.int64(2) + ax3)
                                T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                                T.writes(T_add[v0, v1, v2, v3])
                                T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[1, 1, 2, 58, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 7, 1, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 7, 1, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
l90 = sch.fuse(l53, l59, preserve_unit_iters=True)
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_stage", ann_val=[0, 0, 3])
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_order", ann_val=[0, 1, 2])
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_async_stages", ann_val=[0])
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v91 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v91)
2024-04-28 19:54:16 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 19:54:16 [INFO] [evolutionary_search.cc:715] Picked top 0 candidate(s) from database
2024-04-28 19:54:19 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 488 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 19:54:22 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 970 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 19:54:22 [INFO] [evolutionary_search.cc:723] Sampled 54 candidate(s)
2024-04-28 19:54:28 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 110 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 19:54:35 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 111 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 19:54:41 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 101 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 19:54:47 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 84 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 19:54:47 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	0.9994  0.9992  0.9985  0.9973  0.9970  0.9966  0.9960  0.9954  0.9952  0.9951  0.9940  0.9938  0.9906  0.9902  0.9886  0.9882
[17 : 32]:	0.9880  0.9870  0.9860  0.9846  0.9841  0.9823  0.9823  0.9820  0.9819  0.9815  0.9809  0.9803  0.9795  0.9783  0.9770  0.9763
[33 : 48]:	0.9763  0.9747  0.9747  0.9741  0.9733  0.9730  0.9728  0.9719  0.9714  0.9704  0.9695  0.9692  0.9690  0.9689  0.9686  0.9680
[49 : 64]:	0.9677  0.9675  0.9675  0.9672  0.9663  0.9654  0.9630  0.9624  0.9613  0.9607  0.9598  0.9592  0.9578  0.9578  0.9577  0.9573
2024-04-28 19:54:47 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 19:54:48 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #1: GFLOPs: 22.8813. Time: 18.8793 us. Best GFLOPs: 22.8813
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #2: GFLOPs: 30.2941. Time: 14.2597 us. Best GFLOPs: 30.2941
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #3: GFLOPs: 30.8802. Time: 13.9891 us. Best GFLOPs: 30.8802
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #4: GFLOPs: 34.3924. Time: 12.5604 us. Best GFLOPs: 34.3924
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #5: GFLOPs: 102.8151. Time: 4.2016 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #6: GFLOPs: 67.2836. Time: 6.4203 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #7: GFLOPs: 11.4702. Time: 37.6614 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #8: GFLOPs: 6.9155. Time: 62.4656 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #9: GFLOPs: 65.3153. Time: 6.6138 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #10: GFLOPs: 36.9586. Time: 11.6883 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #11: GFLOPs: 48.7494. Time: 8.8613 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #12: GFLOPs: 61.2148. Time: 7.0569 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #13: GFLOPs: 58.8280. Time: 7.3432 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #14: GFLOPs: 73.5945. Time: 5.8698 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #15: GFLOPs: 36.2818. Time: 11.9063 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #16: GFLOPs: 41.7600. Time: 10.3444 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #17: GFLOPs: 30.1837. Time: 14.3119 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #18: GFLOPs: 84.1553. Time: 5.1332 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #19: GFLOPs: 1.2250. Time: 352.6327 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #20: GFLOPs: 31.1291. Time: 13.8772 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #21: GFLOPs: 67.5885. Time: 6.3914 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #22: GFLOPs: 15.6369. Time: 27.6260 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #23: GFLOPs: 92.4916. Time: 4.6705 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #24: GFLOPs: 21.4385. Time: 20.1499 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #25: GFLOPs: 19.0033. Time: 22.7320 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #26: GFLOPs: 27.7014. Time: 15.5943 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #27: GFLOPs: 22.8870. Time: 18.8747 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #28: GFLOPs: 16.2157. Time: 26.6399 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #29: GFLOPs: 1.9589. Time: 220.5284 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #30: GFLOPs: 65.1091. Time: 6.6348 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #31: GFLOPs: 50.8368. Time: 8.4975 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #32: GFLOPs: 1.1932. Time: 362.0345 us. Best GFLOPs: 102.8151
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #33: GFLOPs: 122.0607. Time: 3.5391 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #34: GFLOPs: 41.7888. Time: 10.3373 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #35: GFLOPs: 27.0557. Time: 15.9665 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #36: GFLOPs: 25.3183. Time: 17.0621 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #37: GFLOPs: 72.2937. Time: 5.9754 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #38: GFLOPs: 45.5431. Time: 9.4852 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #39: GFLOPs: 102.3575. Time: 4.2203 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #40: GFLOPs: 53.9081. Time: 8.0133 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #41: GFLOPs: 67.3381. Time: 6.4151 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #42: GFLOPs: 88.4745. Time: 4.8826 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #43: GFLOPs: 87.0485. Time: 4.9626 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #44: GFLOPs: 30.3521. Time: 14.2324 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #45: GFLOPs: 78.8927. Time: 5.4756 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #46: GFLOPs: 59.6069. Time: 7.2472 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #47: GFLOPs: 107.9488. Time: 4.0017 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #48: GFLOPs: 78.0080. Time: 5.5377 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #49: GFLOPs: 51.6527. Time: 8.3632 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #50: GFLOPs: 52.9981. Time: 8.1509 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #51: GFLOPs: 9.8892. Time: 43.6825 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #52: GFLOPs: 27.7046. Time: 15.5925 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #53: GFLOPs: 7.9842. Time: 54.1047 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #54: GFLOPs: 115.2063. Time: 3.7497 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #55: GFLOPs: 9.2888. Time: 46.5058 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #56: GFLOPs: 111.3993. Time: 3.8778 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #57: GFLOPs: 21.1634. Time: 20.4118 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #58: GFLOPs: 97.5238. Time: 4.4295 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #59: GFLOPs: 78.8531. Time: 5.4783 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #60: GFLOPs: 18.9484. Time: 22.7980 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #61: GFLOPs: 85.8991. Time: 5.0290 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #62: GFLOPs: 48.7445. Time: 8.8622 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #63: GFLOPs: 81.2012. Time: 5.3199 us. Best GFLOPs: 122.0607
2024-04-28 20:20:37 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #64: GFLOPs: 84.2038. Time: 5.1302 us. Best GFLOPs: 122.0607
2024-04-28 20:27:38 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 20:27:38 [INFO] [evolutionary_search.cc:715] Picked top 64 candidate(s) from database
2024-04-28 20:27:41 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 435 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:27:43 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 868 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:27:45 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1292 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:27:45 [INFO] [evolutionary_search.cc:723] Sampled 52 candidate(s)
2024-04-28 20:27:53 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 120 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:28:03 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 114 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:28:13 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 117 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:28:23 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 89 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:28:27 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	1.1392  1.1090  1.0765  1.0733  1.0727  1.0699  1.0628  1.0628  1.0628  1.0625  1.0595  1.0584  1.0582  1.0575  1.0569  1.0565
[17 : 32]:	1.0564  1.0564  1.0525  1.0520  1.0495  1.0473  1.0452  1.0450  1.0445  1.0434  1.0420  1.0415  1.0411  1.0405  1.0403  1.0396
[33 : 48]:	1.0386  1.0369  1.0366  1.0353  1.0353  1.0344  1.0312  1.0312  1.0311  1.0278  1.0245  1.0237  1.0224  1.0184  1.0175  1.0169
[49 : 64]:	1.0166  1.0159  1.0150  1.0149  1.0148  1.0147  1.0138  1.0132  1.0109  1.0102  1.0082  1.0042  0.9977  0.9971  0.9958  0.9942
2024-04-28 20:28:27 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 20:28:27 [INFO] [evolutionary_search.cc:730] Sending 63 candidates(s) for measurement
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #65: GFLOPs: 91.4743. Time: 4.7225 us. Best GFLOPs: 122.0607
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #66: GFLOPs: 103.0187. Time: 4.1933 us. Best GFLOPs: 122.0607
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #67: GFLOPs: 127.6304. Time: 3.3846 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #68: GFLOPs: 124.3805. Time: 3.4731 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #69: GFLOPs: 115.8972. Time: 3.7273 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #70: GFLOPs: 87.3909. Time: 4.9431 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #71: GFLOPs: 119.5842. Time: 3.6124 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #72: GFLOPs: 119.5730. Time: 3.6127 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #73: GFLOPs: 119.5922. Time: 3.6121 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #74: GFLOPs: 107.1157. Time: 4.0329 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #75: GFLOPs: 112.5215. Time: 3.8391 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #76: GFLOPs: 119.5422. Time: 3.6137 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #77: GFLOPs: 91.4436. Time: 4.7240 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #78: GFLOPs: 106.4819. Time: 4.0569 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #79: GFLOPs: 81.6782. Time: 5.2889 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #80: GFLOPs: 124.3434. Time: 3.4741 us. Best GFLOPs: 127.6304
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #81: GFLOPs: 127.9582. Time: 3.3760 us. Best GFLOPs: 127.9582
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #82: GFLOPs: 128.0163. Time: 3.3744 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #83: GFLOPs: 91.6701. Time: 4.7124 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #84: GFLOPs: 112.8997. Time: 3.8263 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #85: GFLOPs: 83.5767. Time: 5.1687 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #86: GFLOPs: 91.9040. Time: 4.7004 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #87: GFLOPs: 112.6593. Time: 3.8344 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #88: GFLOPs: 91.4920. Time: 4.7215 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #89: GFLOPs: 83.5813. Time: 5.1684 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #90: GFLOPs: 112.5607. Time: 3.8378 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #91: GFLOPs: 83.5862. Time: 5.1681 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #92: GFLOPs: 91.4493. Time: 4.7238 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #93: GFLOPs: 113.0445. Time: 3.8214 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #94: GFLOPs: 106.2592. Time: 4.0654 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #95: GFLOPs: 106.4960. Time: 4.0563 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #96: GFLOPs: 127.2458. Time: 3.3949 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #97: GFLOPs: 81.6974. Time: 5.2876 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #98: GFLOPs: 91.3971. Time: 4.7264 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #99: GFLOPs: 113.2584. Time: 3.8141 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #100: GFLOPs: 112.6368. Time: 3.8352 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #101: GFLOPs: 112.6308. Time: 3.8354 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #102: GFLOPs: 112.4882. Time: 3.8403 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #103: GFLOPs: 91.4057. Time: 4.7260 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #104: GFLOPs: 83.5601. Time: 5.1697 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #105: GFLOPs: 83.1055. Time: 5.1980 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #106: GFLOPs: 100.8550. Time: 4.2832 us. Best GFLOPs: 128.0163
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #107: GFLOPs: 136.3220. Time: 3.1689 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #108: GFLOPs: 83.5780. Time: 5.1686 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #109: GFLOPs: 106.5101. Time: 4.0558 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #110: GFLOPs: 127.3185. Time: 3.3929 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #111: GFLOPs: 112.5497. Time: 3.8382 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #112: GFLOPs: 112.7327. Time: 3.8319 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #113: GFLOPs: 117.8329. Time: 3.6661 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #114: GFLOPs: 112.6903. Time: 3.8334 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #115: GFLOPs: 119.4918. Time: 3.6152 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #116: GFLOPs: 112.6646. Time: 3.8342 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #117: GFLOPs: 119.5159. Time: 3.6144 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #118: GFLOPs: 127.4314. Time: 3.3899 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #119: GFLOPs: 112.5723. Time: 3.8374 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #120: GFLOPs: 127.5752. Time: 3.3861 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #121: GFLOPs: 112.6735. Time: 3.8339 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #122: GFLOPs: 127.4241. Time: 3.3901 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #123: GFLOPs: 101.8283. Time: 4.2423 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #124: GFLOPs: 112.5585. Time: 3.8379 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #125: GFLOPs: 97.5621. Time: 4.4278 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #126: GFLOPs: 72.2253. Time: 5.9811 us. Best GFLOPs: 136.3220
2024-04-28 20:29:27 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #127: GFLOPs: 32.6523. Time: 13.2298 us. Best GFLOPs: 136.3220
2024-04-28 20:41:06 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 20:41:07 [INFO] [evolutionary_search.cc:715] Picked top 102 candidate(s) from database
2024-04-28 20:41:10 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 394 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:41:12 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 792 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:41:14 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1185 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:41:16 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1573 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:41:16 [INFO] [evolutionary_search.cc:723] Sampled 67 candidate(s)
2024-04-28 20:41:24 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 119 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:41:33 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 91 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:41:42 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 89 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:41:51 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 93 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:41:55 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	0.9831  0.9654  0.9643  0.9635  0.9581  0.9581  0.9563  0.9563  0.9506  0.9488  0.9478  0.9435  0.9417  0.9416  0.9407  0.9398
[17 : 32]:	0.9389  0.9387  0.9367  0.9363  0.9351  0.9351  0.9342  0.9330  0.9330  0.9293  0.9281  0.9281  0.9267  0.9264  0.9256  0.9245
[33 : 48]:	0.9242  0.9226  0.9225  0.9206  0.9177  0.9177  0.9175  0.9174  0.9159  0.9154  0.9147  0.9147  0.9146  0.9138  0.9138  0.9138
[49 : 64]:	0.9132  0.9129  0.9112  0.9106  0.9091  0.9087  0.9087  0.9065  0.9054  0.9045  0.9045  0.9043  0.9042  0.9041  0.9037  0.9016
2024-04-28 20:41:55 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 20:41:55 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #128: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(3), T.int64(3)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(98))
                                        v2 = T.axis.spatial(T.int64(16), di_0 + b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(98) // T.int64(14))
                                        v3 = T.axis.spatial(T.int64(16), dj_0 + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(14))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(392))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2, v3 = T.axis.remap("SS", [di_0, dj_0])
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(4))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #129: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #130: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(144))
                                    v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(144) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(576))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #131: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #132: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(144))
                                    v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(144) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(576))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #133: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(144))
                                    v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(144) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(576))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #134: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(232), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(3), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2))
                                    v2 = T.axis.spatial(T.int64(16), di_0 + (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(126))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), di_0)
                                    v3 = T.axis.spatial(T.int64(3), ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1)
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(3))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106 = sch.split(loop=l104, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b107 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b107, ann_key="meta_schedule.unroll_explicit")
b108, b109, b110, b111 = sch.get_child_blocks(b107)
l112, l113, l114, l115, l116, l117, l118 = sch.get_loops(block=b108)
l119, l120, l121, l122, l123, l124, l125 = sch.get_loops(block=b109)
l126, l127, l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142 = sch.get_loops(block=b110)
sch.annotate(block_or_loop=l126, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l126, ann_key="pragma_unroll_explicit", ann_val=1)
l143, l144, l145, l146, l147, l148, l149 = sch.get_loops(block=b111)
b150 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l151, l152, l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167 = sch.get_loops(block=b150)
b168 = sch.decompose_reduction(block=b150, loop=l154)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #135: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(232), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(3), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2))
                                    v2 = T.axis.spatial(T.int64(16), di_0 + (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(126))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), di_0)
                                    v3 = T.axis.spatial(T.int64(3), ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1)
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(3))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106 = sch.split(loop=l104, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b107 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b107, ann_key="meta_schedule.unroll_explicit")
b108, b109, b110, b111 = sch.get_child_blocks(b107)
l112, l113, l114, l115, l116, l117, l118 = sch.get_loops(block=b108)
l119, l120, l121, l122, l123, l124, l125 = sch.get_loops(block=b109)
l126, l127, l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142 = sch.get_loops(block=b110)
sch.annotate(block_or_loop=l126, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l126, ann_key="pragma_unroll_explicit", ann_val=1)
l143, l144, l145, l146, l147, l148, l149 = sch.get_loops(block=b111)
b150 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l151, l152, l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167 = sch.get_loops(block=b150)
b168 = sch.decompose_reduction(block=b150, loop=l154)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #136: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #137: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #138: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #139: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #140: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #141: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(3)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(126))
                                    v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(126) // T.int64(14))
                                    v3 = T.axis.spatial(T.int64(16), dj_0 + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(14))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(504))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), dj_0)
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(12))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #142: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #143: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #144: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(2), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #145: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #146: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #147: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #148: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #149: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #150: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #151: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #152: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #153: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(6)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(256))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(256) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(1024))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #154: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #155: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #156: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #157: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #158: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #159: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(6)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(256))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(256) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(1024))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #160: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #161: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #162: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #163: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #164: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(4), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused // T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(6)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(256))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(256) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(1024))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused // T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused // T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #165: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #166: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #167: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(6)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(256))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(256) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(1024))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #168: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #169: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #170: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(203), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(3)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(56))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(56) // T.int64(14))
                                        v3 = T.axis.spatial(T.int64(16), dj_0 + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(14))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), dj_0)
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(12))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[7, 1, 2, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 56, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 56, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #171: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(203), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(3)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(56))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(56) // T.int64(14))
                                        v3 = T.axis.spatial(T.int64(16), dj_0 + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(14))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), dj_0)
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(12))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[7, 1, 2, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 56, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 56, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #172: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(203), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_1_c_1_i_1_j_1_fused + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(3)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(56))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(56) // T.int64(14))
                                        v3 = T.axis.spatial(T.int64(16), dj_0 + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(14))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(168) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(168) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), dj_0)
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(12))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_1_c_1_i_1_j_1_fused + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_1_c_1_i_1_j_1_fused + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[7, 2, 1, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 56, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 56, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #173: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(464), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(4) // T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4))
                                    v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(4) // T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1 < T.int64(81))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(4) // T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(4) // T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 49], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106 = sch.split(loop=l104, factors=[None, 49], preserve_unit_iters=True)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b107 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b107, ann_key="meta_schedule.unroll_explicit")
b108, b109, b110, b111 = sch.get_child_blocks(b107)
l112, l113, l114, l115, l116, l117, l118 = sch.get_loops(block=b108)
l119, l120, l121, l122, l123, l124, l125 = sch.get_loops(block=b109)
l126, l127, l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142 = sch.get_loops(block=b110)
sch.annotate(block_or_loop=l126, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l126, ann_key="pragma_unroll_explicit", ann_val=1)
l143, l144, l145, l146, l147, l148, l149 = sch.get_loops(block=b111)
b150 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l151, l152, l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167 = sch.get_loops(block=b150)
b168 = sch.decompose_reduction(block=b150, loop=l154)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #174: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #175: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #176: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(203), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(112), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(28) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(28) // T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(3)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(112), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(112) + ax0_ax1_ax2_ax3_fused_1) // T.int64(32))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(112) + ax0_ax1_ax2_ax3_fused_1) % T.int64(32) // T.int64(2))
                                    v3 = T.axis.spatial(T.int64(16), dj_0 + b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(112) + ax0_ax1_ax2_ax3_fused_1) % T.int64(2))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(112) + ax0_ax1_ax2_ax3_fused_1 < T.int64(128))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(112), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(336) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(336) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), dj_0)
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(112) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(12))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(28) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(28) // T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(28) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(28) // T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[7, 1, 2, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 112], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 112, 3], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #177: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(144))
                                    v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(144) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(576))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #178: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(784), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(196) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(196) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(784), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1) // T.int64(256))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1) % T.int64(256) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 < T.int64(1024))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(784), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(196) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(196) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(196) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(196) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 784], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106 = sch.split(loop=l104, factors=[None, 784], preserve_unit_iters=True)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b107 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b107, ann_key="meta_schedule.unroll_explicit")
b108, b109, b110, b111 = sch.get_child_blocks(b107)
l112, l113, l114, l115, l116, l117, l118 = sch.get_loops(block=b108)
l119, l120, l121, l122, l123, l124, l125 = sch.get_loops(block=b109)
l126, l127, l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142 = sch.get_loops(block=b110)
sch.annotate(block_or_loop=l126, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l126, ann_key="pragma_unroll_explicit", ann_val=1)
l143, l144, l145, l146, l147, l148, l149 = sch.get_loops(block=b111)
b150 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l151, l152, l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167 = sch.get_loops(block=b150)
b168 = sch.decompose_reduction(block=b150, loop=l154)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #179: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(256))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(256) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(1024))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 392, 2], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #180: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #181: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #182: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #183: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #184: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(6)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(256))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(256) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(1024))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #185: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(6)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(256))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(256) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(1024))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #186: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(256))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(256) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(1024))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1176) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 392, 3], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #187: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(6)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(256))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(256) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(1024))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #188: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #189: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(14), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(28), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(58), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(58) + b_1_c_1_i_1_j_1_fused // T.int64(14) * T.int64(29) + b_2_c_2_i_2_j_2_fused // T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_1_c_1_i_1_j_1_fused % T.int64(14) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0_dj_0_fused in T.serial(T.int64(3), annotations={"software_pipeline_async_stages": [0], "software_pipeline_order": [0, 1, 2], "software_pipeline_stage": [0, 0, 3]}):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(8)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(58), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(58) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(232) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(32))
                                        v2 = T.axis.spatial(T.int64(16), di_0_dj_0_fused + b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(232) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(32) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(232) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(58), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(58) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(174) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), di_0_dj_0_fused)
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(174) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(58) + b_1_c_1_i_1_j_1_fused // T.int64(14) * T.int64(29) + b_2_c_2_i_2_j_2_fused // T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_1_c_1_i_1_j_1_fused % T.int64(14) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0_dj_0_fused + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(58) + b_1_c_1_i_1_j_1_fused // T.int64(14) * T.int64(29) + b_2_c_2_i_2_j_2_fused // T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_1_c_1_i_1_j_1_fused % T.int64(14) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[2, 2, 29, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[7, 2, 1, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 7, 2, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
l90 = sch.fuse(l53, l59, preserve_unit_iters=True)
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_stage", ann_val=[0, 0, 3])
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_order", ann_val=[0, 1, 2])
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_async_stages", ann_val=[0])
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v91 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v91)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 58, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 58, 3], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126 = sch.get_loops(block=b110)
l127, l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142 = sch.get_loops(block=b111)
l143, l144, l145, l146, l147, l148, l149 = sch.get_loops(block=b112)
b150 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l151, l152, l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166 = sch.get_loops(block=b150)
b167 = sch.decompose_reduction(block=b150, loop=l154)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #190: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0_dj_0_fused in T.serial(T.int64(3), annotations={"software_pipeline_async_stages": [0], "software_pipeline_order": [0, 1, 2], "software_pipeline_stage": [0, 0, 3]}):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(5)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(112))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(112) // T.int64(7))
                                    v3 = T.axis.spatial(T.int64(16), di_0_dj_0_fused + b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(7))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(448))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), di_0_dj_0_fused)
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(12))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), di_0_dj_0_fused + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
l90 = sch.fuse(l53, l59, preserve_unit_iters=True)
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_stage", ann_val=[0, 0, 3])
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_order", ann_val=[0, 1, 2])
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_async_stages", ann_val=[0])
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v91 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v91)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103 = sch.get_loops(block=b78)
l104, l105 = sch.split(loop=l103, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l105, thread_axis="threadIdx.x")
b106 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b106, ann_key="meta_schedule.unroll_explicit")
b107, b108, b109, b110 = sch.get_child_blocks(b106)
l111, l112, l113, l114, l115, l116 = sch.get_loops(block=b107)
l117, l118, l119, l120, l121, l122 = sch.get_loops(block=b108)
l123, l124, l125, l126, l127, l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138 = sch.get_loops(block=b109)
sch.annotate(block_or_loop=l123, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l123, ann_key="pragma_unroll_explicit", ann_val=1)
l139, l140, l141, l142, l143, l144, l145 = sch.get_loops(block=b110)
b146 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l147, l148, l149, l150, l151, l152, l153, l154, l155, l156, l157, l158, l159, l160, l161, l162 = sch.get_loops(block=b146)
b163 = sch.decompose_reduction(block=b146, loop=l150)
2024-04-28 20:42:26 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #191: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(56), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(2), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(203), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(14) * T.int64(29) + b_2_c_2_i_2_j_2_fused // T.int64(7) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(14) // T.int64(7) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_1_c_1_i_1_j_1_fused + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0_dj_0_fused in T.serial(T.int64(3), annotations={"software_pipeline_async_stages": [0], "software_pipeline_order": [0, 1, 2], "software_pipeline_stage": [0, 0, 2]}):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(203), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(14) * T.int64(29) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(812) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(28))
                                        v2 = T.axis.spatial(T.int64(16), di_0_dj_0_fused + b_0_c_0_i_0_j_0_fused % T.int64(14) // T.int64(7) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(812) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(28) // T.int64(4))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(812) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(4))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(203), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(14) * T.int64(29) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(609) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), di_0_dj_0_fused)
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(609) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(203) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(87))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(14) * T.int64(29) + b_2_c_2_i_2_j_2_fused // T.int64(7) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(14) // T.int64(7) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_1_c_1_i_1_j_1_fused + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0_dj_0_fused + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(14) * T.int64(29) + b_2_c_2_i_2_j_2_fused // T.int64(7) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(14) // T.int64(7) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_1_c_1_i_1_j_1_fused + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[4, 1, 29, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[7, 2, 1, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
l90 = sch.fuse(l53, l59, preserve_unit_iters=True)
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_stage", ann_val=[0, 0, 2])
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_order", ann_val=[0, 1, 2])
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_async_stages", ann_val=[0])
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v91 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v91)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 203, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 203, 3], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126 = sch.get_loops(block=b110)
l127, l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l127, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l127, ann_key="pragma_unroll_explicit", ann_val=1)
l143, l144, l145, l146, l147, l148, l149 = sch.get_loops(block=b112)
b150 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l151, l152, l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166 = sch.get_loops(block=b150)
b167 = sch.decompose_reduction(block=b150, loop=l154)
2024-04-28 20:58:12 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 20:58:13 [INFO] [evolutionary_search.cc:715] Picked top 102 candidate(s) from database
2024-04-28 20:58:15 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 391 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:58:17 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 783 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:58:19 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1170 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:58:19 [INFO] [evolutionary_search.cc:723] Sampled 60 candidate(s)
2024-04-28 20:58:26 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 95 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:58:35 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 93 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:58:44 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 80 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:58:53 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 99 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 20:58:56 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	0.9708  0.9595  0.9461  0.9461  0.9399  0.9298  0.9292  0.9264  0.9229  0.9229  0.9229  0.9224  0.9216  0.9216  0.9210  0.9210
[17 : 32]:	0.9196  0.9196  0.9182  0.9177  0.9177  0.9168  0.9129  0.9104  0.9093  0.9088  0.9075  0.9075  0.9052  0.9052  0.9049  0.9042
[33 : 48]:	0.9039  0.9039  0.9018  0.9018  0.9006  0.8982  0.8977  0.8977  0.8973  0.8970  0.8970  0.8969  0.8958  0.8942  0.8936  0.8936
[49 : 64]:	0.8936  0.8935  0.8918  0.8918  0.8916  0.8916  0.8915  0.8915  0.8910  0.8893  0.8889  0.8889  0.8869  0.8869  0.8864  0.8858
2024-04-28 20:58:56 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 20:58:56 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #192: GFLOPs: 138.5422. Time: 3.1181 us. Best GFLOPs: 138.5422
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #193: GFLOPs: 129.3957. Time: 3.3385 us. Best GFLOPs: 138.5422
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #194: GFLOPs: 130.6395. Time: 3.3067 us. Best GFLOPs: 138.5422
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #195: GFLOPs: 130.6240. Time: 3.3071 us. Best GFLOPs: 138.5422
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #196: GFLOPs: 139.6154. Time: 3.0941 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #197: GFLOPs: 129.4720. Time: 3.3365 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #198: GFLOPs: 130.7448. Time: 3.3040 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #199: GFLOPs: 130.5743. Time: 3.3083 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #200: GFLOPs: 122.1110. Time: 3.5376 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #201: GFLOPs: 122.1317. Time: 3.5370 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #202: GFLOPs: 122.2463. Time: 3.5337 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #203: GFLOPs: 122.4458. Time: 3.5280 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #204: GFLOPs: 129.7224. Time: 3.3301 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #205: GFLOPs: 129.7089. Time: 3.3304 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #206: GFLOPs: 129.5553. Time: 3.3344 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #207: GFLOPs: 129.5518. Time: 3.3344 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #208: GFLOPs: 122.3593. Time: 3.5305 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #209: GFLOPs: 122.4641. Time: 3.5274 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #210: GFLOPs: 129.4888. Time: 3.3361 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #211: GFLOPs: 130.6928. Time: 3.3053 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #212: GFLOPs: 130.6219. Time: 3.3071 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #213: GFLOPs: 121.7243. Time: 3.5489 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #214: GFLOPs: 130.7097. Time: 3.3049 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #215: GFLOPs: 111.9922. Time: 3.8573 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #216: GFLOPs: 129.5216. Time: 3.3352 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #217: GFLOPs: 128.0478. Time: 3.3736 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #218: GFLOPs: 112.1014. Time: 3.8535 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #219: GFLOPs: 130.5255. Time: 3.3096 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #220: GFLOPs: 112.4622. Time: 3.8411 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #221: GFLOPs: 112.4633. Time: 3.8411 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #222: GFLOPs: 118.4247. Time: 3.6478 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #223: GFLOPs: 130.4611. Time: 3.3112 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #224: GFLOPs: 130.7689. Time: 3.3034 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #225: GFLOPs: 130.7233. Time: 3.3046 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #226: GFLOPs: 114.7647. Time: 3.7641 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #227: GFLOPs: 121.0368. Time: 3.5690 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #228: GFLOPs: 129.3943. Time: 3.3385 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #229: GFLOPs: 114.6448. Time: 3.7680 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #230: GFLOPs: 130.4916. Time: 3.3104 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #231: GFLOPs: 130.4052. Time: 3.3126 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #232: GFLOPs: 112.2102. Time: 3.8498 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #233: GFLOPs: 114.5143. Time: 3.7723 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #234: GFLOPs: 138.4730. Time: 3.1196 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #235: GFLOPs: 129.4219. Time: 3.3378 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #236: GFLOPs: 130.4299. Time: 3.3120 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #237: GFLOPs: 130.6907. Time: 3.3054 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #238: GFLOPs: 121.4718. Time: 3.5562 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #239: GFLOPs: 121.4677. Time: 3.5564 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #240: GFLOPs: 121.4386. Time: 3.5572 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #241: GFLOPs: 121.4851. Time: 3.5559 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #242: GFLOPs: 138.5953. Time: 3.1169 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #243: GFLOPs: 72.8315. Time: 5.9313 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #244: GFLOPs: 121.4654. Time: 3.5564 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #245: GFLOPs: 121.4558. Time: 3.5567 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #246: GFLOPs: 114.2789. Time: 3.7801 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #247: GFLOPs: 114.3111. Time: 3.7790 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #248: GFLOPs: 121.4596. Time: 3.5566 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #249: GFLOPs: 130.4639. Time: 3.3111 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #250: GFLOPs: 130.3285. Time: 3.3146 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #251: GFLOPs: 130.5226. Time: 3.3096 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #252: GFLOPs: 129.3451. Time: 3.3398 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #253: GFLOPs: 11.9117. Time: 36.2656 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #254: GFLOPs: 15.2963. Time: 28.2411 us. Best GFLOPs: 139.6154
2024-04-28 21:00:02 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #255: GFLOPs: 7.8344. Time: 55.1392 us. Best GFLOPs: 139.6154
2024-04-28 21:11:16 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 21:11:17 [INFO] [evolutionary_search.cc:715] Picked top 102 candidate(s) from database
2024-04-28 21:11:20 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 393 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:11:22 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 784 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:11:24 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1177 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:11:24 [INFO] [evolutionary_search.cc:723] Sampled 53 candidate(s)
2024-04-28 21:11:31 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 91 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:11:40 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 88 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:11:48 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 95 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:11:57 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 73 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:12:01 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	0.9776  0.9776  0.9744  0.9730  0.9730  0.9662  0.9617  0.9614  0.9591  0.9584  0.9576  0.9559  0.9461  0.9449  0.9443  0.9437
[17 : 32]:	0.9437  0.9426  0.9401  0.9371  0.9363  0.9363  0.9357  0.9357  0.9327  0.9304  0.9300  0.9300  0.9299  0.9298  0.9298  0.9298
[33 : 48]:	0.9293  0.9287  0.9287  0.9282  0.9278  0.9278  0.9275  0.9271  0.9268  0.9267  0.9267  0.9267  0.9264  0.9264  0.9264  0.9263
[49 : 64]:	0.9262  0.9262  0.9262  0.9258  0.9254  0.9254  0.9254  0.9253  0.9252  0.9250  0.9242  0.9240  0.9239  0.9233  0.9229  0.9229
2024-04-28 21:12:01 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 21:12:01 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #256: GFLOPs: 141.6927. Time: 3.0487 us. Best GFLOPs: 141.6927
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #257: GFLOPs: 141.6987. Time: 3.0486 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #258: GFLOPs: 141.6766. Time: 3.0491 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #259: GFLOPs: 131.9353. Time: 3.2742 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #260: GFLOPs: 131.9229. Time: 3.2745 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #261: GFLOPs: 114.0149. Time: 3.7888 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #262: GFLOPs: 122.6896. Time: 3.5210 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #263: GFLOPs: 122.6981. Time: 3.5207 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #264: GFLOPs: 141.6622. Time: 3.0494 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #265: GFLOPs: 131.9070. Time: 3.2749 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #266: GFLOPs: 123.7652. Time: 3.4904 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #267: GFLOPs: 141.6839. Time: 3.0489 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #268: GFLOPs: 131.9475. Time: 3.2739 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #269: GFLOPs: 130.2836. Time: 3.3157 us. Best GFLOPs: 141.6987
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #270: GFLOPs: 141.7665. Time: 3.0472 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #271: GFLOPs: 132.4585. Time: 3.2613 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #272: GFLOPs: 132.1776. Time: 3.2682 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #273: GFLOPs: 131.8990. Time: 3.2751 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #274: GFLOPs: 123.1574. Time: 3.5076 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #275: GFLOPs: 141.6922. Time: 3.0487 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #276: GFLOPs: 130.1402. Time: 3.3194 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #277: GFLOPs: 130.7778. Time: 3.3032 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #278: GFLOPs: 131.7534. Time: 3.2787 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #279: GFLOPs: 131.7808. Time: 3.2780 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #280: GFLOPs: 131.7797. Time: 3.2781 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #281: GFLOPs: 131.9227. Time: 3.2745 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #282: GFLOPs: 131.7430. Time: 3.2790 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #283: GFLOPs: 123.0239. Time: 3.5114 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #284: GFLOPs: 131.9104. Time: 3.2748 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #285: GFLOPs: 131.7601. Time: 3.2786 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #286: GFLOPs: 131.5758. Time: 3.2832 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #287: GFLOPs: 131.7358. Time: 3.2792 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #288: GFLOPs: 131.7822. Time: 3.2780 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #289: GFLOPs: 131.7771. Time: 3.2781 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #290: GFLOPs: 131.7792. Time: 3.2781 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #291: GFLOPs: 131.9117. Time: 3.2748 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #292: GFLOPs: 131.8993. Time: 3.2751 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #293: GFLOPs: 131.9136. Time: 3.2747 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #294: GFLOPs: 131.9474. Time: 3.2739 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #295: GFLOPs: 131.8901. Time: 3.2753 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #296: GFLOPs: 123.2407. Time: 3.5052 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #297: GFLOPs: 131.9206. Time: 3.2746 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #298: GFLOPs: 131.7602. Time: 3.2786 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #299: GFLOPs: 131.7578. Time: 3.2786 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #300: GFLOPs: 131.9138. Time: 3.2747 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #301: GFLOPs: 132.0197. Time: 3.2721 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #302: GFLOPs: 131.9043. Time: 3.2750 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #303: GFLOPs: 131.7489. Time: 3.2788 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #304: GFLOPs: 131.7082. Time: 3.2799 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #305: GFLOPs: 131.7489. Time: 3.2788 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #306: GFLOPs: 131.7532. Time: 3.2787 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #307: GFLOPs: 131.9169. Time: 3.2747 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #308: GFLOPs: 131.9154. Time: 3.2747 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #309: GFLOPs: 131.8968. Time: 3.2752 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #310: GFLOPs: 131.7658. Time: 3.2784 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #311: GFLOPs: 131.5024. Time: 3.2850 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #312: GFLOPs: 131.9098. Time: 3.2748 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #313: GFLOPs: 131.6170. Time: 3.2821 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #314: GFLOPs: 131.9172. Time: 3.2747 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #315: GFLOPs: 131.8765. Time: 3.2757 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #316: GFLOPs: 131.9470. Time: 3.2739 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #317: GFLOPs: 38.1150. Time: 11.3337 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #318: GFLOPs: 51.7021. Time: 8.3552 us. Best GFLOPs: 141.7665
2024-04-28 21:13:01 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #319: GFLOPs: 29.6881. Time: 14.5507 us. Best GFLOPs: 141.7665
2024-04-28 21:27:36 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 21:27:37 [INFO] [evolutionary_search.cc:715] Picked top 102 candidate(s) from database
2024-04-28 21:27:39 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 390 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:27:41 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 778 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:27:43 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1172 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:27:43 [INFO] [evolutionary_search.cc:723] Sampled 58 candidate(s)
2024-04-28 21:27:49 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 69 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:27:58 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 97 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:28:07 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 87 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:28:15 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 114 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:28:19 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	0.9828  0.9655  0.9636  0.9630  0.9608  0.9573  0.9572  0.9548  0.9487  0.9472  0.9472  0.9447  0.9447  0.9444  0.9444  0.9434
[17 : 32]:	0.9415  0.9399  0.9388  0.9385  0.9382  0.9374  0.9374  0.9374  0.9374  0.9367  0.9365  0.9363  0.9359  0.9359  0.9358  0.9348
[33 : 48]:	0.9341  0.9334  0.9330  0.9327  0.9325  0.9322  0.9319  0.9319  0.9317  0.9310  0.9310  0.9303  0.9302  0.9300  0.9294  0.9293
[49 : 64]:	0.9293  0.9284  0.9284  0.9282  0.9282  0.9279  0.9278  0.9275  0.9275  0.9274  0.9274  0.9274  0.9273  0.9270  0.9270  0.9267
2024-04-28 21:28:19 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 21:28:19 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #320: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(232), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(144))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 49, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 49, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #321: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(18))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #322: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(4), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_1_c_1_i_1_j_1_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(6)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(256))
                                    v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(256) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(1024))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_1_c_1_i_1_j_1_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_1_c_1_i_1_j_1_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 2, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 2, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106 = sch.split(loop=l104, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b107 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b107, ann_key="meta_schedule.unroll_explicit")
b108, b109, b110, b111 = sch.get_child_blocks(b107)
l112, l113, l114, l115, l116, l117, l118 = sch.get_loops(block=b108)
l119, l120, l121, l122, l123, l124, l125 = sch.get_loops(block=b109)
l126, l127, l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142 = sch.get_loops(block=b110)
sch.annotate(block_or_loop=l126, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l126, ann_key="pragma_unroll_explicit", ann_val=1)
l143, l144, l145, l146, l147, l148, l149 = sch.get_loops(block=b111)
b150 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l151, l152, l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167 = sch.get_loops(block=b150)
b168 = sch.decompose_reduction(block=b150, loop=l154)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #323: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #324: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #325: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(18))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #326: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #327: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #328: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(18))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #329: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(18))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #330: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(18))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #331: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #332: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #333: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #334: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #335: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #336: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #337: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #338: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #339: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:51 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #340: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #341: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #342: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #343: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #344: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #345: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #346: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #347: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #348: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #349: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #350: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #351: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #352: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #353: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #354: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #355: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #356: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #357: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #358: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #359: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #360: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #361: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(203), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(2) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(64))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(64) // T.int64(4))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(4))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(2) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(2) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[7, 1, 2, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 56, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 56], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #362: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(203), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(2) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(64))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(64) // T.int64(4))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(4))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(2) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(2) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[7, 1, 2, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 56, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 56], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #363: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #364: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #365: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #366: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #367: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #368: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #369: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #370: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #371: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #372: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #373: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #374: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #375: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 392, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #376: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1568) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(392), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 392, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 392], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #377: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #378: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #379: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #380: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #381: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(7), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(29), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(112), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_1_c_1_i_1_j_1_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(28) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(28) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(67)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(112), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), (ax0_ax1_ax2_ax3_fused_0 * T.int64(112) + ax0_ax1_ax2_ax3_fused_1) // T.int64(64))
                                    v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(112) + ax0_ax1_ax2_ax3_fused_1) % T.int64(64) // T.int64(16))
                                    v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(112) + ax0_ax1_ax2_ax3_fused_1) % T.int64(16))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(112) + ax0_ax1_ax2_ax3_fused_1 < T.int64(7424))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(112), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), (ax0_ax1_ax2_ax3_fused_0 * T.int64(448) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(448) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(448) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(112) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1044))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_1_c_1_i_1_j_1_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(28) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(28) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_1_c_1_i_1_j_1_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(28) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(28) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[1, 29, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[7, 1, 2, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 112], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 112, 4], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #382: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(14), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(14), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(58), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_1_c_1_i_1_j_1_fused // T.int64(7) * T.int64(58) + b_2_c_2_i_2_j_2_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(7) + b_1_c_1_i_1_j_1_fused % T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(3), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(56)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(58), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), (ax0_ax1_ax2_ax3_fused_0 * T.int64(58) + ax0_ax1_ax2_ax3_fused_1) // T.int64(28))
                                    v2 = T.axis.spatial(T.int64(16), di_0 + b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(58) + ax0_ax1_ax2_ax3_fused_1) % T.int64(28) // T.int64(4))
                                    v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(58) + ax0_ax1_ax2_ax3_fused_1) % T.int64(4))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(58), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), (ax0_ax1_ax2_ax3_fused_0 * T.int64(116) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), di_0)
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(116) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_1_c_1_i_1_j_1_fused // T.int64(7) * T.int64(58) + b_2_c_2_i_2_j_2_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(7) + b_1_c_1_i_1_j_1_fused % T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_1_c_1_i_1_j_1_fused // T.int64(7) * T.int64(58) + b_2_c_2_i_2_j_2_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(7) + b_1_c_1_i_1_j_1_fused % T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[1, 2, 58, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 7, 1, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[7, 1, 1, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 58], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 58, 2], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:28:52 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #383: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(7), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(14), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(58), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_1_c_1_i_1_j_1_fused // T.int64(7) * T.int64(58) + b_2_c_2_i_2_j_2_fused // T.int64(2) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(3), T.int64(3)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(56)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(58), thread="threadIdx.x"):
                                with T.block("PaddedInput_shared"):
                                    v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v1 = T.axis.spatial(T.int64(116), (ax0_ax1_ax2_ax3_fused_0 * T.int64(58) + ax0_ax1_ax2_ax3_fused_1) // T.int64(28))
                                    v2 = T.axis.spatial(T.int64(16), di_0 + (ax0_ax1_ax2_ax3_fused_0 * T.int64(58) + ax0_ax1_ax2_ax3_fused_1) % T.int64(28) // T.int64(2))
                                    v3 = T.axis.spatial(T.int64(16), dj_0 + b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(58) + ax0_ax1_ax2_ax3_fused_1) % T.int64(2))
                                    T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                    T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                    PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(58), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), ax0_ax1_ax2_ax3_fused_0 * T.int64(58) + ax0_ax1_ax2_ax3_fused_1)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2, v3 = T.axis.remap("SS", [di_0, dj_0])
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_1_c_1_i_1_j_1_fused // T.int64(7) * T.int64(58) + b_2_c_2_i_2_j_2_fused // T.int64(2) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_1_c_1_i_1_j_1_fused // T.int64(7) * T.int64(58) + b_2_c_2_i_2_j_2_fused // T.int64(2) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[1, 2, 29, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 7, 2, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[7, 1, 1, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98 = sch.split(loop=l96, factors=[None, 58], preserve_unit_iters=True)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l99, l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106 = sch.split(loop=l104, factors=[None, 58], preserve_unit_iters=True)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b107 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b107, ann_key="meta_schedule.unroll_explicit")
b108, b109, b110, b111 = sch.get_child_blocks(b107)
l112, l113, l114, l115, l116, l117, l118 = sch.get_loops(block=b108)
l119, l120, l121, l122, l123, l124, l125 = sch.get_loops(block=b109)
l126, l127, l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142 = sch.get_loops(block=b110)
sch.annotate(block_or_loop=l126, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l126, ann_key="pragma_unroll_explicit", ann_val=1)
l143, l144, l145, l146, l147, l148, l149 = sch.get_loops(block=b111)
b150 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l151, l152, l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167 = sch.get_loops(block=b150)
b168 = sch.decompose_reduction(block=b150, loop=l154)
2024-04-28 21:44:55 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 21:44:56 [INFO] [evolutionary_search.cc:715] Picked top 102 candidate(s) from database
2024-04-28 21:44:58 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 399 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:45:01 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 797 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:45:03 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1188 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:45:05 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1568 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:45:05 [INFO] [evolutionary_search.cc:723] Sampled 72 candidate(s)
2024-04-28 21:45:12 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 76 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:45:20 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 81 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:45:29 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 75 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:45:38 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 99 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 21:45:42 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	0.9778  0.9443  0.9405  0.9360  0.9360  0.9360  0.9354  0.9354  0.9352  0.9335  0.9328  0.9315  0.9315  0.9310  0.9306  0.9302
[17 : 32]:	0.9292  0.9285  0.9277  0.9274  0.9273  0.9261  0.9261  0.9257  0.9257  0.9252  0.9247  0.9247  0.9245  0.9245  0.9232  0.9231
[33 : 48]:	0.9231  0.9224  0.9224  0.9222  0.9222  0.9221  0.9220  0.9219  0.9219  0.9219  0.9219  0.9219  0.9215  0.9215  0.9213  0.9206
[49 : 64]:	0.9206  0.9203  0.9200  0.9197  0.9196  0.9193  0.9188  0.9184  0.9183  0.9179  0.9178  0.9178  0.9175  0.9175  0.9174  0.9171
2024-04-28 21:45:42 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 21:45:42 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #384: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(232), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(144))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 49, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 49], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #385: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #386: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #387: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(232), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(144))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 49, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 49, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #388: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(232), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(144))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(49), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(147) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(49) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 49, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 49, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #389: Error in running:
LocalRunner: An exception occurred
Subprocess terminated
# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(2)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(1024))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #390: GFLOPs: 131.9234. Time: 3.2745 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #391: GFLOPs: 133.5853. Time: 3.2338 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #392: GFLOPs: 125.1076. Time: 3.4529 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #393: GFLOPs: 134.2771. Time: 3.2171 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #394: GFLOPs: 133.6277. Time: 3.2327 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #395: GFLOPs: 134.8046. Time: 3.2045 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #396: GFLOPs: 127.8335. Time: 3.3793 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #397: GFLOPs: 133.6261. Time: 3.2328 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #398: GFLOPs: 134.9080. Time: 3.2021 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #399: GFLOPs: 131.4725. Time: 3.2857 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #400: GFLOPs: 133.9058. Time: 3.2260 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #401: GFLOPs: 134.7080. Time: 3.2068 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #402: GFLOPs: 133.5804. Time: 3.2339 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #403: GFLOPs: 132.5551. Time: 3.2589 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #404: GFLOPs: 133.4899. Time: 3.2361 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #405: GFLOPs: 133.5555. Time: 3.2345 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #406: GFLOPs: 133.5652. Time: 3.2343 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #407: GFLOPs: 133.2090. Time: 3.2429 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #408: GFLOPs: 133.1983. Time: 3.2432 us. Best GFLOPs: 141.7665
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #409: GFLOPs: 143.3333. Time: 3.0138 us. Best GFLOPs: 143.3333
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #410: GFLOPs: 133.1354. Time: 3.2447 us. Best GFLOPs: 143.3333
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #411: GFLOPs: 128.5572. Time: 3.3602 us. Best GFLOPs: 143.3333
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #412: GFLOPs: 134.8744. Time: 3.2029 us. Best GFLOPs: 143.3333
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #413: GFLOPs: 134.7686. Time: 3.2054 us. Best GFLOPs: 143.3333
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #414: GFLOPs: 143.6040. Time: 3.0082 us. Best GFLOPs: 143.6040
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #415: GFLOPs: 143.6259. Time: 3.0077 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #416: GFLOPs: 133.4439. Time: 3.2372 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #417: GFLOPs: 132.6495. Time: 3.2566 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #418: GFLOPs: 129.9743. Time: 3.3236 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #419: GFLOPs: 132.6176. Time: 3.2574 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #420: GFLOPs: 132.6014. Time: 3.2578 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #421: GFLOPs: 133.6504. Time: 3.2322 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #422: GFLOPs: 134.0026. Time: 3.2237 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #423: GFLOPs: 134.8673. Time: 3.2030 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #424: GFLOPs: 126.1591. Time: 3.4241 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #425: GFLOPs: 126.1391. Time: 3.4247 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #426: GFLOPs: 133.7554. Time: 3.2297 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #427: GFLOPs: 126.1046. Time: 3.4256 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #428: GFLOPs: 133.4003. Time: 3.2383 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #429: GFLOPs: 133.4467. Time: 3.2371 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #430: GFLOPs: 133.8281. Time: 3.2279 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #431: GFLOPs: 127.8326. Time: 3.3793 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #432: GFLOPs: 133.5971. Time: 3.2335 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #433: GFLOPs: 134.8760. Time: 3.2028 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #434: GFLOPs: 124.4188. Time: 3.4720 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #435: GFLOPs: 133.4905. Time: 3.2361 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #436: GFLOPs: 134.5238. Time: 3.2112 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #437: GFLOPs: 133.6077. Time: 3.2332 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #438: GFLOPs: 133.4437. Time: 3.2372 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #439: GFLOPs: 133.6157. Time: 3.2330 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #440: GFLOPs: 133.6373. Time: 3.2325 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #441: GFLOPs: 133.5650. Time: 3.2343 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #442: GFLOPs: 132.9789. Time: 3.2485 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #443: GFLOPs: 132.1038. Time: 3.2700 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #444: GFLOPs: 117.9800. Time: 3.6615 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #445: GFLOPs: 43.9990. Time: 9.8180 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #446: GFLOPs: 11.5348. Time: 37.4504 us. Best GFLOPs: 143.6259
2024-04-28 21:46:45 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #447: GFLOPs: 69.1903. Time: 6.2434 us. Best GFLOPs: 143.6259
2024-04-28 22:00:51 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 22:00:53 [INFO] [evolutionary_search.cc:715] Picked top 102 candidate(s) from database
2024-04-28 22:00:55 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 393 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:00:57 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 793 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:00:59 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1191 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:01:01 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1587 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:01:01 [INFO] [evolutionary_search.cc:723] Sampled 53 candidate(s)
2024-04-28 22:01:08 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 85 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:01:17 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 105 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:01:26 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 90 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:01:35 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 106 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:01:39 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	0.9905  0.9666  0.9611  0.9498  0.9498  0.9498  0.9498  0.9495  0.9491  0.9484  0.9476  0.9474  0.9472  0.9454  0.9454  0.9433
[17 : 32]:	0.9416  0.9411  0.9404  0.9402  0.9392  0.9390  0.9388  0.9380  0.9380  0.9379  0.9378  0.9375  0.9372  0.9364  0.9364  0.9352
[33 : 48]:	0.9347  0.9344  0.9343  0.9335  0.9333  0.9328  0.9323  0.9313  0.9309  0.9309  0.9309  0.9309  0.9309  0.9306  0.9295  0.9275
[49 : 64]:	0.9275  0.9275  0.9272  0.9269  0.9268  0.9267  0.9262  0.9259  0.9259  0.9255  0.9254  0.9253  0.9252  0.9252  0.9249  0.9245
2024-04-28 22:01:39 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 22:01:39 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #448: GFLOPs: 127.1686. Time: 3.3969 us. Best GFLOPs: 143.6259
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #449: GFLOPs: 127.1782. Time: 3.3967 us. Best GFLOPs: 143.6259
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #450: GFLOPs: 138.4507. Time: 3.1201 us. Best GFLOPs: 143.6259
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #451: GFLOPs: 146.4721. Time: 2.9493 us. Best GFLOPs: 146.4721
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #452: GFLOPs: 146.4595. Time: 2.9495 us. Best GFLOPs: 146.4721
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #453: GFLOPs: 146.4595. Time: 2.9495 us. Best GFLOPs: 146.4721
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #454: GFLOPs: 146.4301. Time: 2.9501 us. Best GFLOPs: 146.4721
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #455: GFLOPs: 146.4454. Time: 2.9498 us. Best GFLOPs: 146.4721
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #456: GFLOPs: 147.9283. Time: 2.9202 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #457: GFLOPs: 146.4219. Time: 2.9503 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #458: GFLOPs: 147.6163. Time: 2.9264 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #459: GFLOPs: 147.3080. Time: 2.9325 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #460: GFLOPs: 146.4592. Time: 2.9495 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #461: GFLOPs: 142.2541. Time: 3.0367 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #462: GFLOPs: 142.5271. Time: 3.0309 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #463: GFLOPs: 119.3105. Time: 3.6207 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #464: GFLOPs: 146.4957. Time: 2.9488 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #465: GFLOPs: 138.0890. Time: 3.1283 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #466: GFLOPs: 141.4033. Time: 3.0550 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #467: GFLOPs: 146.3202. Time: 2.9523 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #468: GFLOPs: 136.1503. Time: 3.1728 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #469: GFLOPs: 136.1146. Time: 3.1737 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #470: GFLOPs: 136.0507. Time: 3.1752 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #471: GFLOPs: 136.1784. Time: 3.1722 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #472: GFLOPs: 136.1735. Time: 3.1723 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #473: GFLOPs: 146.4848. Time: 2.9490 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #474: GFLOPs: 136.1134. Time: 3.1737 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #475: GFLOPs: 136.1398. Time: 3.1731 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #476: GFLOPs: 146.4959. Time: 2.9488 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #477: GFLOPs: 136.1111. Time: 3.1738 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #478: GFLOPs: 136.1847. Time: 3.1720 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #479: GFLOPs: 136.1704. Time: 3.1724 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #480: GFLOPs: 136.1136. Time: 3.1737 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #481: GFLOPs: 136.1211. Time: 3.1735 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #482: GFLOPs: 136.0789. Time: 3.1745 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #483: GFLOPs: 136.1354. Time: 3.1732 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #484: GFLOPs: 112.4040. Time: 3.8431 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #485: GFLOPs: 136.0591. Time: 3.1750 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #486: GFLOPs: 114.4927. Time: 3.7730 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #487: GFLOPs: 146.4115. Time: 2.9505 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #488: GFLOPs: 117.2124. Time: 3.6855 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #489: GFLOPs: 116.8047. Time: 3.6983 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #490: GFLOPs: 146.2458. Time: 2.9538 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #491: GFLOPs: 116.8459. Time: 3.6970 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #492: GFLOPs: 117.2606. Time: 3.6840 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #493: GFLOPs: 136.1011. Time: 3.1740 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #494: GFLOPs: 116.9459. Time: 3.6939 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #495: GFLOPs: 112.5413. Time: 3.8385 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #496: GFLOPs: 136.2699. Time: 3.1701 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #497: GFLOPs: 136.2397. Time: 3.1708 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #498: GFLOPs: 136.2434. Time: 3.1707 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #499: GFLOPs: 136.2676. Time: 3.1701 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #500: GFLOPs: 127.3405. Time: 3.3924 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #501: GFLOPs: 136.2631. Time: 3.1702 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #502: GFLOPs: 136.3081. Time: 3.1692 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #503: GFLOPs: 136.2552. Time: 3.1704 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #504: GFLOPs: 136.2797. Time: 3.1698 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #505: GFLOPs: 136.1376. Time: 3.1731 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #506: GFLOPs: 127.7203. Time: 3.3823 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #507: GFLOPs: 136.2664. Time: 3.1701 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #508: GFLOPs: 136.1049. Time: 3.1739 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #509: GFLOPs: 48.3435. Time: 8.9357 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #510: GFLOPs: 64.2639. Time: 6.7220 us. Best GFLOPs: 147.9283
2024-04-28 22:02:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #511: GFLOPs: 71.2919. Time: 6.0594 us. Best GFLOPs: 147.9283
2024-04-28 22:18:54 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 22:18:55 [INFO] [evolutionary_search.cc:715] Picked top 102 candidate(s) from database
2024-04-28 22:18:57 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 383 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:18:59 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 778 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:19:01 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1175 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:19:01 [INFO] [evolutionary_search.cc:723] Sampled 55 candidate(s)
2024-04-28 22:19:08 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 100 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:19:17 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 96 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:19:25 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 99 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:19:34 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 103 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:19:38 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	1.0024  0.9903  0.9900  0.9889  0.9881  0.9881  0.9863  0.9835  0.9835  0.9797  0.9781  0.9754  0.9754  0.9740  0.9731  0.9713
[17 : 32]:	0.9713  0.9710  0.9708  0.9697  0.9689  0.9689  0.9689  0.9653  0.9639  0.9625  0.9600  0.9598  0.9597  0.9579  0.9579  0.9576
[33 : 48]:	0.9569  0.9569  0.9563  0.9560  0.9538  0.9537  0.9512  0.9511  0.9511  0.9480  0.9452  0.9402  0.9400  0.9350  0.9341  0.9341
[49 : 64]:	0.9341  0.9325  0.9315  0.9306  0.9304  0.9290  0.9284  0.9279  0.9273  0.9272  0.9263  0.9261  0.9255  0.9226  0.9224  0.9218
2024-04-28 22:19:38 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 22:19:38 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #512: GFLOPs: 138.9602. Time: 3.1087 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #513: GFLOPs: 138.8969. Time: 3.1101 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #514: GFLOPs: 132.4174. Time: 3.2623 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #515: GFLOPs: 147.0528. Time: 2.9376 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #516: GFLOPs: 140.1882. Time: 3.0815 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #517: GFLOPs: 140.3959. Time: 3.0769 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #518: GFLOPs: 139.3632. Time: 3.0997 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #519: GFLOPs: 139.3940. Time: 3.0990 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #520: GFLOPs: 139.4205. Time: 3.0984 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #521: GFLOPs: 147.0264. Time: 2.9381 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #522: GFLOPs: 147.0648. Time: 2.9374 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #523: GFLOPs: 147.0764. Time: 2.9371 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #524: GFLOPs: 147.0540. Time: 2.9376 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #525: GFLOPs: 146.9745. Time: 2.9392 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #526: GFLOPs: 132.5697. Time: 3.2585 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #527: GFLOPs: 147.0560. Time: 2.9375 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #528: GFLOPs: 147.0588. Time: 2.9375 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #529: GFLOPs: 147.0550. Time: 2.9376 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #530: GFLOPs: 147.0550. Time: 2.9376 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #531: GFLOPs: 142.4712. Time: 3.0321 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #532: GFLOPs: 147.0342. Time: 2.9380 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #533: GFLOPs: 147.0427. Time: 2.9378 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #534: GFLOPs: 147.0576. Time: 2.9375 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #535: GFLOPs: 132.2899. Time: 3.2654 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #536: GFLOPs: 134.1003. Time: 3.2213 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #537: GFLOPs: 131.9443. Time: 3.2740 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #538: GFLOPs: 132.3868. Time: 3.2630 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #539: GFLOPs: 132.3393. Time: 3.2642 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #540: GFLOPs: 131.9770. Time: 3.2732 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #541: GFLOPs: 137.2135. Time: 3.1483 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #542: GFLOPs: 137.2926. Time: 3.1464 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #543: GFLOPs: 132.5133. Time: 3.2599 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #544: GFLOPs: 132.3389. Time: 3.2642 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #545: GFLOPs: 134.3679. Time: 3.2149 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #546: GFLOPs: 133.6031. Time: 3.2333 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #547: GFLOPs: 146.9857. Time: 2.9390 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #548: GFLOPs: 134.2671. Time: 3.2173 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #549: GFLOPs: 132.3579. Time: 3.2638 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #550: GFLOPs: 133.5796. Time: 3.2339 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #551: GFLOPs: 132.3747. Time: 3.2633 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #552: GFLOPs: 132.0463. Time: 3.2715 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #553: GFLOPs: 132.4046. Time: 3.2626 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #554: GFLOPs: 122.5655. Time: 3.5245 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #555: GFLOPs: 139.5237. Time: 3.0961 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #556: GFLOPs: 135.0094. Time: 3.1997 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #557: GFLOPs: 139.4307. Time: 3.0982 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #558: GFLOPs: 124.1942. Time: 3.4783 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #559: GFLOPs: 132.3291. Time: 3.2645 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #560: GFLOPs: 132.3369. Time: 3.2643 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #561: GFLOPs: 132.3868. Time: 3.2630 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #562: GFLOPs: 132.3278. Time: 3.2645 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #563: GFLOPs: 132.5328. Time: 3.2595 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #564: GFLOPs: 131.9602. Time: 3.2736 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #565: GFLOPs: 135.1313. Time: 3.1968 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #566: GFLOPs: 135.0534. Time: 3.1986 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #567: GFLOPs: 131.8565. Time: 3.2762 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #568: GFLOPs: 135.0403. Time: 3.1989 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #569: GFLOPs: 135.0364. Time: 3.1990 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #570: GFLOPs: 135.0807. Time: 3.1980 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #571: GFLOPs: 135.0616. Time: 3.1984 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #572: GFLOPs: 132.8479. Time: 3.2517 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #573: GFLOPs: 25.1218. Time: 17.1956 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #574: GFLOPs: 84.9589. Time: 5.0846 us. Best GFLOPs: 147.9283
2024-04-28 22:20:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #575: GFLOPs: 3.7176. Time: 116.1992 us. Best GFLOPs: 147.9283
2024-04-28 22:36:20 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 22:36:21 [INFO] [evolutionary_search.cc:715] Picked top 102 candidate(s) from database
2024-04-28 22:36:23 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 395 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:36:25 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 784 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:36:28 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1177 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:36:28 [INFO] [evolutionary_search.cc:723] Sampled 53 candidate(s)
2024-04-28 22:36:34 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 133 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:36:43 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 105 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:36:52 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 109 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:37:01 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 90 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:37:04 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	1.0208  1.0195  1.0191  1.0191  1.0174  0.9831  0.9831  0.9821  0.9781  0.9781  0.9760  0.9760  0.9758  0.9739  0.9734  0.9723
[17 : 32]:	0.9723  0.9722  0.9722  0.9722  0.9720  0.9708  0.9707  0.9697  0.9697  0.9652  0.9652  0.9640  0.9633  0.9629  0.9619  0.9619
[33 : 48]:	0.9598  0.9597  0.9592  0.9590  0.9581  0.9581  0.9578  0.9570  0.9562  0.9562  0.9558  0.9543  0.9543  0.9538  0.9523  0.9511
[49 : 64]:	0.9492  0.9473  0.9468  0.9461  0.9456  0.9448  0.9428  0.9420  0.9419  0.9390  0.9379  0.9378  0.9364  0.9363  0.9363  0.9341
2024-04-28 22:37:04 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 22:37:04 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #576: GFLOPs: 147.4664. Time: 2.9294 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #577: GFLOPs: 146.7082. Time: 2.9445 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #578: GFLOPs: 147.4659. Time: 2.9294 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #579: GFLOPs: 147.4393. Time: 2.9299 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #580: GFLOPs: 147.4466. Time: 2.9298 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #581: GFLOPs: 147.3460. Time: 2.9318 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #582: GFLOPs: 147.3671. Time: 2.9313 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #583: GFLOPs: 147.3718. Time: 2.9313 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #584: GFLOPs: 147.3394. Time: 2.9319 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #585: GFLOPs: 147.3518. Time: 2.9317 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #586: GFLOPs: 147.4427. Time: 2.9298 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #587: GFLOPs: 147.4283. Time: 2.9301 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #588: GFLOPs: 143.8517. Time: 3.0030 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #589: GFLOPs: 147.4311. Time: 2.9301 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #590: GFLOPs: 147.3061. Time: 2.9326 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #591: GFLOPs: 147.4753. Time: 2.9292 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #592: GFLOPs: 147.3532. Time: 2.9316 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #593: GFLOPs: 145.5738. Time: 2.9675 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #594: GFLOPs: 145.5824. Time: 2.9673 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #595: GFLOPs: 145.8245. Time: 2.9624 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #596: GFLOPs: 145.1858. Time: 2.9754 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #597: GFLOPs: 147.4002. Time: 2.9307 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #598: GFLOPs: 147.3405. Time: 2.9319 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #599: GFLOPs: 147.3320. Time: 2.9320 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #600: GFLOPs: 147.4435. Time: 2.9298 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #601: GFLOPs: 147.4336. Time: 2.9300 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #602: GFLOPs: 147.4303. Time: 2.9301 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #603: GFLOPs: 147.4351. Time: 2.9300 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #604: GFLOPs: 128.1754. Time: 3.3703 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #605: GFLOPs: 147.4690. Time: 2.9293 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #606: GFLOPs: 147.4615. Time: 2.9295 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #607: GFLOPs: 147.4611. Time: 2.9295 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #608: GFLOPs: 147.4466. Time: 2.9298 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #609: GFLOPs: 147.4259. Time: 2.9302 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #610: GFLOPs: 147.4501. Time: 2.9297 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #611: GFLOPs: 147.4003. Time: 2.9307 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #612: GFLOPs: 147.4368. Time: 2.9300 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #613: GFLOPs: 147.4294. Time: 2.9301 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #614: GFLOPs: 147.4381. Time: 2.9299 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #615: GFLOPs: 147.4492. Time: 2.9297 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #616: GFLOPs: 147.4420. Time: 2.9299 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #617: GFLOPs: 146.9679. Time: 2.9393 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #618: GFLOPs: 147.4302. Time: 2.9301 us. Best GFLOPs: 147.9283
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #619: GFLOPs: 148.0037. Time: 2.9187 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #620: GFLOPs: 148.0005. Time: 2.9188 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #621: GFLOPs: 147.4197. Time: 2.9303 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #622: GFLOPs: 120.3997. Time: 3.5879 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #623: GFLOPs: 147.4274. Time: 2.9301 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #624: GFLOPs: 140.2041. Time: 3.0811 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #625: GFLOPs: 147.9002. Time: 2.9208 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #626: GFLOPs: 147.4292. Time: 2.9301 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #627: GFLOPs: 147.4644. Time: 2.9294 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #628: GFLOPs: 140.1062. Time: 3.0833 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #629: GFLOPs: 140.1080. Time: 3.0832 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #630: GFLOPs: 147.4544. Time: 2.9296 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #631: GFLOPs: 147.1441. Time: 2.9358 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #632: GFLOPs: 140.1547. Time: 3.0822 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #633: GFLOPs: 137.9367. Time: 3.1318 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #634: GFLOPs: 147.1615. Time: 2.9354 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #635: GFLOPs: 140.2010. Time: 3.0812 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #636: GFLOPs: 138.6611. Time: 3.1154 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #637: GFLOPs: 44.2995. Time: 9.7514 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #638: GFLOPs: 44.1979. Time: 9.7739 us. Best GFLOPs: 148.0037
2024-04-28 22:38:08 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #639: GFLOPs: 42.3119. Time: 10.2095 us. Best GFLOPs: 148.0037
2024-04-28 22:51:50 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 22:51:51 [INFO] [evolutionary_search.cc:715] Picked top 102 candidate(s) from database
2024-04-28 22:51:53 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 388 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:51:55 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 786 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:51:57 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1184 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:52:00 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1581 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:52:00 [INFO] [evolutionary_search.cc:723] Sampled 59 candidate(s)
2024-04-28 22:52:07 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 115 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:52:16 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 106 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:52:25 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 103 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:52:34 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 100 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 22:52:38 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	0.9946  0.9924  0.9916  0.9915  0.9906  0.9899  0.9897  0.9870  0.9866  0.9860  0.9860  0.9859  0.9854  0.9854  0.9852  0.9850
[17 : 32]:	0.9834  0.9805  0.9798  0.9796  0.9792  0.9773  0.9750  0.9750  0.9744  0.9744  0.9742  0.9740  0.9740  0.9706  0.9701  0.9701
[33 : 48]:	0.9701  0.9673  0.9656  0.9652  0.9652  0.9645  0.9639  0.9635  0.9625  0.9625  0.9611  0.9606  0.9588  0.9588  0.9586  0.9574
[49 : 64]:	0.9553  0.9528  0.9522  0.9522  0.9517  0.9507  0.9507  0.9506  0.9504  0.9503  0.9503  0.9501  0.9500  0.9492  0.9490  0.9486
2024-04-28 22:52:38 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 22:52:38 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #640: GFLOPs: 143.7075. Time: 3.0060 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #641: GFLOPs: 143.0619. Time: 3.0196 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #642: GFLOPs: 143.7307. Time: 3.0055 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #643: GFLOPs: 142.9935. Time: 3.0210 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #644: GFLOPs: 142.8988. Time: 3.0230 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #645: GFLOPs: 143.6974. Time: 3.0062 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #646: GFLOPs: 144.0028. Time: 2.9998 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #647: GFLOPs: 143.7054. Time: 3.0060 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #648: GFLOPs: 143.5437. Time: 3.0094 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #649: GFLOPs: 143.1926. Time: 3.0168 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #650: GFLOPs: 143.1645. Time: 3.0174 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #651: GFLOPs: 143.3265. Time: 3.0140 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #652: GFLOPs: 143.4746. Time: 3.0109 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #653: GFLOPs: 143.4990. Time: 3.0104 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #654: GFLOPs: 143.0920. Time: 3.0189 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #655: GFLOPs: 142.8492. Time: 3.0241 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #656: GFLOPs: 144.7956. Time: 2.9834 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #657: GFLOPs: 143.7084. Time: 3.0060 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #658: GFLOPs: 143.8877. Time: 3.0022 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #659: GFLOPs: 143.6712. Time: 3.0068 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #660: GFLOPs: 143.0348. Time: 3.0201 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #661: GFLOPs: 143.5784. Time: 3.0087 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #662: GFLOPs: 143.1530. Time: 3.0176 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #663: GFLOPs: 143.0862. Time: 3.0190 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #664: GFLOPs: 143.5883. Time: 3.0085 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #665: GFLOPs: 143.5970. Time: 3.0083 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #666: GFLOPs: 143.9825. Time: 3.0003 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #667: GFLOPs: 143.6452. Time: 3.0073 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #668: GFLOPs: 143.6498. Time: 3.0072 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #669: GFLOPs: 143.6836. Time: 3.0065 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #670: GFLOPs: 143.3808. Time: 3.0128 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #671: GFLOPs: 143.3462. Time: 3.0136 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #672: GFLOPs: 143.6848. Time: 3.0065 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #673: GFLOPs: 143.6057. Time: 3.0081 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #674: GFLOPs: 143.6612. Time: 3.0070 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #675: GFLOPs: 143.6762. Time: 3.0067 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #676: GFLOPs: 143.6688. Time: 3.0068 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #677: GFLOPs: 143.6787. Time: 3.0066 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #678: GFLOPs: 143.6886. Time: 3.0064 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #679: GFLOPs: 133.6198. Time: 3.2329 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #680: GFLOPs: 133.6604. Time: 3.2320 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #681: GFLOPs: 133.6590. Time: 3.2320 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #682: GFLOPs: 143.4622. Time: 3.0111 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #683: GFLOPs: 143.6660. Time: 3.0069 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #684: GFLOPs: 143.6947. Time: 3.0063 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #685: GFLOPs: 143.6912. Time: 3.0063 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #686: GFLOPs: 143.6749. Time: 3.0067 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #687: GFLOPs: 133.6068. Time: 3.2332 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #688: GFLOPs: 143.0838. Time: 3.0191 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #689: GFLOPs: 143.6700. Time: 3.0068 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #690: GFLOPs: 143.6749. Time: 3.0067 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #691: GFLOPs: 143.6676. Time: 3.0068 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #692: GFLOPs: 127.6736. Time: 3.3835 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #693: GFLOPs: 143.5454. Time: 3.0094 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #694: GFLOPs: 143.5388. Time: 3.0095 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #695: GFLOPs: 143.6286. Time: 3.0076 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #696: GFLOPs: 143.6291. Time: 3.0076 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #697: GFLOPs: 143.6738. Time: 3.0067 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #698: GFLOPs: 143.6762. Time: 3.0067 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #699: GFLOPs: 143.6130. Time: 3.0080 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #700: GFLOPs: 143.5399. Time: 3.0095 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #701: GFLOPs: 85.4366. Time: 5.0562 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #702: GFLOPs: 78.2646. Time: 5.5195 us. Best GFLOPs: 148.0037
2024-04-28 22:53:39 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #703: GFLOPs: 37.8985. Time: 11.3984 us. Best GFLOPs: 148.0037
2024-04-28 23:06:13 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 23:06:14 [INFO] [evolutionary_search.cc:715] Picked top 102 candidate(s) from database
2024-04-28 23:06:17 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 393 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:06:19 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 783 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:06:21 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1177 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:06:21 [INFO] [evolutionary_search.cc:723] Sampled 53 candidate(s)
2024-04-28 23:06:28 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 116 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:06:36 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 111 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:06:45 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 95 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:06:54 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 81 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:06:57 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	0.9850  0.9831  0.9831  0.9827  0.9813  0.9810  0.9810  0.9788  0.9767  0.9766  0.9765  0.9765  0.9764  0.9764  0.9762  0.9761
[17 : 32]:	0.9761  0.9760  0.9750  0.9749  0.9746  0.9741  0.9741  0.9731  0.9725  0.9725  0.9722  0.9716  0.9716  0.9714  0.9707  0.9706
[33 : 48]:	0.9696  0.9695  0.9690  0.9690  0.9689  0.9687  0.9687  0.9681  0.9679  0.9676  0.9676  0.9673  0.9673  0.9670  0.9670  0.9670
[49 : 64]:	0.9660  0.9660  0.9657  0.9650  0.9650  0.9650  0.9640  0.9637  0.9634  0.9629  0.9621  0.9620  0.9614  0.9613  0.9613  0.9613
2024-04-28 23:06:58 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 23:06:58 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #704: GFLOPs: 143.0984. Time: 3.0188 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #705: GFLOPs: 144.8082. Time: 2.9831 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #706: GFLOPs: 143.6947. Time: 3.0063 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #707: GFLOPs: 144.3939. Time: 2.9917 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #708: GFLOPs: 143.4099. Time: 3.0122 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #709: GFLOPs: 144.1886. Time: 2.9960 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #710: GFLOPs: 144.2158. Time: 2.9954 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #711: GFLOPs: 143.6826. Time: 3.0065 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #712: GFLOPs: 143.1049. Time: 3.0187 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #713: GFLOPs: 143.4721. Time: 3.0109 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #714: GFLOPs: 143.6908. Time: 3.0063 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #715: GFLOPs: 143.2672. Time: 3.0152 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #716: GFLOPs: 143.6942. Time: 3.0063 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #717: GFLOPs: 143.6873. Time: 3.0064 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #718: GFLOPs: 143.3622. Time: 3.0132 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #719: GFLOPs: 143.6786. Time: 3.0066 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #720: GFLOPs: 143.6864. Time: 3.0064 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #721: GFLOPs: 143.6852. Time: 3.0065 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #722: GFLOPs: 143.6917. Time: 3.0063 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #723: GFLOPs: 143.3077. Time: 3.0144 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #724: GFLOPs: 143.6580. Time: 3.0070 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #725: GFLOPs: 143.6893. Time: 3.0064 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #726: GFLOPs: 143.6834. Time: 3.0065 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #727: GFLOPs: 143.9719. Time: 3.0005 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #728: GFLOPs: 143.7025. Time: 3.0061 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #729: GFLOPs: 143.7047. Time: 3.0061 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #730: GFLOPs: 143.6752. Time: 3.0067 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #731: GFLOPs: 143.1320. Time: 3.0181 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #732: GFLOPs: 143.9840. Time: 3.0002 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #733: GFLOPs: 143.6345. Time: 3.0075 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #734: GFLOPs: 143.6537. Time: 3.0071 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #735: GFLOPs: 143.2241. Time: 3.0161 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #736: GFLOPs: 143.7171. Time: 3.0058 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #737: GFLOPs: 143.4226. Time: 3.0120 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #738: GFLOPs: 143.1084. Time: 3.0186 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #739: GFLOPs: 143.7182. Time: 3.0058 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #740: GFLOPs: 143.6947. Time: 3.0063 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #741: GFLOPs: 143.5413. Time: 3.0095 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #742: GFLOPs: 143.5151. Time: 3.0100 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #743: GFLOPs: 144.2475. Time: 2.9947 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #744: GFLOPs: 143.7059. Time: 3.0060 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #745: GFLOPs: 143.7109. Time: 3.0059 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #746: GFLOPs: 143.6102. Time: 3.0080 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #747: GFLOPs: 143.5983. Time: 3.0083 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #748: GFLOPs: 143.5851. Time: 3.0086 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #749: GFLOPs: 143.6746. Time: 3.0067 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #750: GFLOPs: 143.6853. Time: 3.0065 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #751: GFLOPs: 144.2193. Time: 2.9953 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #752: GFLOPs: 143.5325. Time: 3.0097 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #753: GFLOPs: 143.5561. Time: 3.0092 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #754: GFLOPs: 143.6316. Time: 3.0076 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #755: GFLOPs: 143.7022. Time: 3.0061 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #756: GFLOPs: 143.6884. Time: 3.0064 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #757: GFLOPs: 143.6911. Time: 3.0063 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #758: GFLOPs: 143.7009. Time: 3.0061 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #759: GFLOPs: 143.6972. Time: 3.0062 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #760: GFLOPs: 143.5338. Time: 3.0096 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #761: GFLOPs: 143.5151. Time: 3.0100 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #762: GFLOPs: 143.6649. Time: 3.0069 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #763: GFLOPs: 143.6679. Time: 3.0068 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #764: GFLOPs: 143.5284. Time: 3.0097 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #765: GFLOPs: 22.8932. Time: 18.8695 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #766: GFLOPs: 81.8980. Time: 5.2747 us. Best GFLOPs: 148.0037
2024-04-28 23:07:58 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #767: GFLOPs: 80.4034. Time: 5.3727 us. Best GFLOPs: 148.0037
2024-04-28 23:26:02 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 23:26:03 [INFO] [evolutionary_search.cc:715] Picked top 102 candidate(s) from database
2024-04-28 23:26:05 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 394 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:26:07 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 784 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:26:10 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1175 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:26:10 [INFO] [evolutionary_search.cc:723] Sampled 55 candidate(s)
2024-04-28 23:26:16 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 105 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:26:25 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 103 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:26:33 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 108 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:26:42 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 102 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:26:45 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	0.9870  0.9843  0.9812  0.9812  0.9803  0.9799  0.9798  0.9786  0.9786  0.9782  0.9764  0.9751  0.9750  0.9746  0.9732  0.9723
[17 : 32]:	0.9717  0.9717  0.9716  0.9711  0.9703  0.9698  0.9695  0.9690  0.9689  0.9682  0.9682  0.9681  0.9677  0.9675  0.9673  0.9654
[33 : 48]:	0.9652  0.9650  0.9650  0.9648  0.9647  0.9646  0.9643  0.9641  0.9628  0.9622  0.9618  0.9614  0.9614  0.9612  0.9604  0.9604
[49 : 64]:	0.9599  0.9599  0.9596  0.9596  0.9589  0.9578  0.9502  0.9483  0.9476  0.9467  0.9467  0.9449  0.9449  0.9441  0.9440  0.9414
2024-04-28 23:26:46 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 23:26:46 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #768: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #769: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #770: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #771: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #772: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #773: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #774: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #775: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #776: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #777: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #778: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(18))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #779: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #780: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #781: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #782: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #783: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(288))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #784: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #785: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #786: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(288))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #787: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #788: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(18))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #789: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(288))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(18))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #790: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #791: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(288))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(18))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #792: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #793: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(288))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #794: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #795: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #796: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #797: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(288))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #798: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 2, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #799: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #800: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #801: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #802: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #803: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(288))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #804: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(18))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 1, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #805: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(4) // T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(81))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(4) // T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(81) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(324))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(4) // T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(4) // T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #806: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #807: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #808: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #809: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #810: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #811: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #812: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(576))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 < T.int64(36))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(98) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(14) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 196], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #813: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #814: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #815: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #816: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #817: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #818: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #819: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1 < T.int64(9))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 98], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #820: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #821: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(256))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused)
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(9))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[116, 1, 1, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #822: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x"):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) * T.int64(2) + c_3_init * T.int64(2) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(4) // T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(81))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(4) // T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(81) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(324))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(36))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) * T.int64(2) + c_3 * T.int64(2) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(4) // T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(2), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(4) * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(49) * T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(4) // T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 2, 1, 2])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=0)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 4], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #823: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #824: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(116), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(144))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(144) // T.int64(9))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(294) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(288))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(98), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(98) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 * T.int64(3) + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused // T.int64(2) * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(49) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(49) // T.int64(7) * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(2) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(7) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 98, 3], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 98, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #825: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #826: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(392) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(2) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 2], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #827: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init * T.int64(2) + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 * T.int64(2) + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 1, 2])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #828: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(58), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 16, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(256))
                                        v2 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(256) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(784) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(512))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(196), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(3)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) // T.int64(9))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(9) // T.int64(3))
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(588) + ax0_ax1_ax2_ax3_fused_1 * T.int64(3) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(196) + ax0_ax1_ax2_ax3_fused_1) * T.int64(3) + ax0_ax1_ax2_ax3_fused_2 < T.int64(18))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(3), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(2)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(2) + b_2_c_2_i_2_j_2_fused // T.int64(98) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(98) // T.int64(7) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(7) * T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[58, 1, 2, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 7, 2, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=1)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 196, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107, l108 = sch.split(loop=l105, factors=[None, 196, 3], preserve_unit_iters=True)
sch.vectorize(loop=l108)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b109 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b109, ann_key="meta_schedule.unroll_explicit")
b110, b111, b112, b113 = sch.get_child_blocks(b109)
l114, l115, l116, l117, l118, l119, l120, l121 = sch.get_loops(block=b110)
l122, l123, l124, l125, l126, l127, l128, l129 = sch.get_loops(block=b111)
l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144, l145, l146 = sch.get_loops(block=b112)
sch.annotate(block_or_loop=l130, ann_key="pragma_auto_unroll_max_step", ann_val=16)
sch.annotate(block_or_loop=l130, ann_key="pragma_unroll_explicit", ann_val=1)
l147, l148, l149, l150, l151, l152, l153 = sch.get_loops(block=b113)
b154 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169, l170, l171 = sch.get_loops(block=b154)
b172 = sch.decompose_reduction(block=b154, loop=l158)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #829: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(14), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 512, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(1), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(406), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(4), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(4) + c_3_init * T.int64(4) + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(1), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(406), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), (ax0_ax1_ax2_ax3_fused_0 * T.int64(1624) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(36))
                                        v2 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(7) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1624) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(36) // T.int64(4))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(1624) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(4))
                                        T.where((ax0_ax1_ax2_ax3_fused_0 * T.int64(406) + ax0_ax1_ax2_ax3_fused_1) * T.int64(4) + ax0_ax1_ax2_ax3_fused_2 < T.int64(4176))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(406), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), (ax0_ax1_ax2_ax3_fused_0 * T.int64(406) + ax0_ax1_ax2_ax3_fused_1) // T.int64(9))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(406) + ax0_ax1_ax2_ax3_fused_1) % T.int64(9) // T.int64(3))
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(406) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(406) + ax0_ax1_ax2_ax3_fused_1 < T.int64(1044))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(4), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(4) + c_3 * T.int64(4) + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 * T.int64(3) + di_1 * T.int64(3) + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(4), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_2_c_2_i_2_j_2_fused // T.int64(14) * T.int64(4) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(7) + b_2_c_2_i_2_j_2_fused % T.int64(14) // T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[1, 1, 29, 1, 4])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[2, 1, 7, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[7, 1, 2, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[1, 1, 3])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=3)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 406, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 406], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=512)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #830: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(29), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 64, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(7), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(2) + i_3_init * T.int64(2) + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0, dj_0 in T.grid(T.int64(3), T.int64(1)):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(4)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(4)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) // T.int64(224))
                                        v2 = T.axis.spatial(T.int64(16), di_0 + (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(224) // T.int64(16))
                                        v3 = T.axis.spatial(T.int64(16), (ax0_ax1_ax2_ax3_fused_0 * T.int64(224) + ax0_ax1_ax2_ax3_fused_1 * T.int64(4) + ax0_ax1_ax2_ax3_fused_2) % T.int64(16))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(1)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(56), thread="threadIdx.x"):
                                with T.block("p1_shared"):
                                    v0 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) // T.int64(3))
                                    v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                    v2 = T.axis.spatial(T.int64(3), di_0)
                                    v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1) % T.int64(3))
                                    T.where(ax0_ax1_ax2_ax3_fused_0 * T.int64(56) + ax0_ax1_ax2_ax3_fused_1 < T.int64(12))
                                    T.reads(p1[v0, v1, v2, v3])
                                    T.writes(p1_shared[v0, v1, v2, v3])
                                    p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(2) + i_3 * T.int64(2) + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0 + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_0 * T.int64(3) + dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(2), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_0_c_0_i_0_j_0_fused * T.int64(4) + b_2_c_2_i_2_j_2_fused // T.int64(14) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_1_c_1_i_1_j_1_fused * T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_2_c_2_i_2_j_2_fused % T.int64(14) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[29, 1, 4, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[1, 7, 1, 1, 2])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[1, 1, 14, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=0)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v90 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=2)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v90)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l91, l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 56, 4], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104, l105 = sch.get_loops(block=b78)
l106, l107 = sch.split(loop=l105, factors=[None, 56], preserve_unit_iters=True)
sch.bind(loop=l107, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119, l120 = sch.get_loops(block=b109)
l121, l122, l123, l124, l125, l126, l127 = sch.get_loops(block=b110)
l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142, l143, l144 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l128, ann_key="pragma_auto_unroll_max_step", ann_val=64)
sch.annotate(block_or_loop=l128, ann_key="pragma_unroll_explicit", ann_val=1)
l145, l146, l147, l148, l149, l150, l151 = sch.get_loops(block=b112)
b152 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166, l167, l168, l169 = sch.get_loops(block=b152)
b170 = sch.decompose_reduction(block=b152, loop=l156)
2024-04-28 23:27:18 [INFO] [task_scheduler.cc:121] [Task #4: fused_nn_conv2d_add_1] Trial #831: Error in running:
LocalRunner: An exception occurred
Traceback (most recent call last):
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/exec/popen_worker.py", line 87, in main
    result = fn(*args, **kwargs)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 152, in _worker_func
    repeated_args: List[T_ARGUMENT_LIST] = f_alloc_argument(
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/local_runner.py", line 360, in default_alloc_argument
    return alloc_argument_common(f_random_fill, device, args_info, alloc_repeat)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 74, in alloc_argument_common
    arg: Any = dispatcher.get(arg_type, None)(*arg_info)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/meta_schedule/runner/utils.py", line 56, in alloc_tensor
    arg = ndarray.empty(shape=shape, dtype=dtype, device=device)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/runtime/ndarray.py", line 391, in empty
    arr = _ffi_api.TVMArrayAllocWithScope(shape, dtype, device, mem_scope)
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/mnt/home/gverma/ceph/opt/tvm/python/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm.error.InternalError: Traceback (most recent call last):
  5: _ZN3tvm7runtime13PackedFun
  4: tvm::runtime::TypedPackedFunc<tvm::runtime::NDArray (tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>::AssignTypedLambda<tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)>(tvm::runtime::NDArray (*)(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  3: tvm::runtime::NDArray::Empty(tvm::runtime::ShapeTuple, DLDataType, DLDevice, tvm::runtime::Optional<tvm::runtime::String>)
  2: tvm::runtime::DeviceAPI::AllocDataSpace(DLDevice, int, long const*, DLDataType, tvm::runtime::Optional<tvm::runtime::String>)
  1: tvm::runtime::CUDADeviceAPI::AllocDataSpace(DLDevice, unsigned long, unsigned long, DLDataType)
  0: _ZN3tvm7runtime6deta
  File "/mnt/home/gverma/ceph/opt/tvm/src/runtime/cuda/cuda_device_api.cc", line 126
InternalError: Check failed: (e == cudaSuccess || e == cudaErrorCudartUnloading) is false: CUDA: misaligned address

# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(p0: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32"), p1: T.Buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), "float32"), p2: T.Buffer((T.int64(1), T.int64(116), T.int64(1), T.int64(1)), "float32"), T_add: T.Buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), "float32")):
        T.func_attr({"tir.noalias": T.bool(True)})
        # with T.block("root"):
        DepthwiseConv2d_local = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(14), T.int64(14)), scope="local")
        PaddedInput_shared = T.alloc_buffer((T.int64(1), T.int64(116), T.int64(16), T.int64(16)), scope="shared")
        p1_shared = T.alloc_buffer((T.int64(116), T.int64(1), T.int64(3), T.int64(3)), scope="shared")
        for b_0_c_0_i_0_j_0_fused in T.thread_binding(T.int64(49), thread="blockIdx.x", annotations={"pragma_auto_unroll_max_step": 1024, "pragma_unroll_explicit": 1}):
            for b_1_c_1_i_1_j_1_fused in T.thread_binding(T.int64(8), thread="vthread.x"):
                for b_2_c_2_i_2_j_2_fused in T.thread_binding(T.int64(58), thread="threadIdx.x"):
                    for b_3_init, c_3_init, i_3_init, j_3_init, b_4_init, c_4_init, i_4_init, j_4_init in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_init"):
                            v_b = T.axis.spatial(T.int64(1), b_3_init + b_4_init)
                            v_c = T.axis.spatial(T.int64(116), b_1_c_1_i_1_j_1_fused // T.int64(2) * T.int64(29) + b_2_c_2_i_2_j_2_fused // T.int64(2) + c_3_init + c_4_init)
                            v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + i_3_init + i_4_init)
                            v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_1_c_1_i_1_j_1_fused % T.int64(2) + j_3_init + j_4_init)
                            T.reads()
                            T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                            T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                            DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = T.float32(0)
                    for di_0_dj_0_fused in T.serial(T.int64(3), annotations={"software_pipeline_async_stages": [0], "software_pipeline_order": [0, 1, 2], "software_pipeline_stage": [0, 0, 3]}):
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(8)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(58), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("PaddedInput_shared"):
                                        v0 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v1 = T.axis.spatial(T.int64(116), (ax0_ax1_ax2_ax3_fused_0 * T.int64(116) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(8))
                                        v2 = T.axis.spatial(T.int64(16), di_0_dj_0_fused + b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(116) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(8) // T.int64(4))
                                        v3 = T.axis.spatial(T.int64(16), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + (ax0_ax1_ax2_ax3_fused_0 * T.int64(116) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(4))
                                        T.reads(p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)])
                                        T.writes(PaddedInput_shared[v0, v1, v2, v3])
                                        PaddedInput_shared[v0, v1, v2, v3] = T.if_then_else(T.int64(1) <= v2 and v2 < T.int64(15) and T.int64(1) <= v3 and v3 < T.int64(15), p0[v0, v1, v2 - T.int64(1), v3 - T.int64(1)], T.float32(0))
                        for ax0_ax1_ax2_ax3_fused_0 in range(T.int64(3)):
                            for ax0_ax1_ax2_ax3_fused_1 in T.thread_binding(T.int64(58), thread="threadIdx.x"):
                                for ax0_ax1_ax2_ax3_fused_2 in T.vectorized(T.int64(2)):
                                    with T.block("p1_shared"):
                                        v0 = T.axis.spatial(T.int64(116), (ax0_ax1_ax2_ax3_fused_0 * T.int64(116) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) // T.int64(3))
                                        v1 = T.axis.spatial(T.int64(1), T.int64(0))
                                        v2 = T.axis.spatial(T.int64(3), di_0_dj_0_fused)
                                        v3 = T.axis.spatial(T.int64(3), (ax0_ax1_ax2_ax3_fused_0 * T.int64(116) + ax0_ax1_ax2_ax3_fused_1 * T.int64(2) + ax0_ax1_ax2_ax3_fused_2) % T.int64(3))
                                        T.reads(p1[v0, v1, v2, v3])
                                        T.writes(p1_shared[v0, v1, v2, v3])
                                        p1_shared[v0, v1, v2, v3] = p1[v0, v1, v2, v3]
                        for di_1, dj_1, b_3, c_3, i_3, j_3, di_2, dj_2, b_4, c_4, i_4, j_4 in T.grid(T.int64(1), T.int64(3), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                            with T.block("DepthwiseConv2d_update"):
                                v_b = T.axis.spatial(T.int64(1), b_3 + b_4)
                                v_c = T.axis.spatial(T.int64(116), b_1_c_1_i_1_j_1_fused // T.int64(2) * T.int64(29) + b_2_c_2_i_2_j_2_fused // T.int64(2) + c_3 + c_4)
                                v_i = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + i_3 + i_4)
                                v_j = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_1_c_1_i_1_j_1_fused % T.int64(2) + j_3 + j_4)
                                v_di = T.axis.reduce(T.int64(3), di_0_dj_0_fused + di_1 + di_2)
                                v_dj = T.axis.reduce(T.int64(3), dj_1 + dj_2)
                                T.reads(DepthwiseConv2d_local[v_b, v_c, v_i, v_j], PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj], p1_shared[v_c, T.int64(0), v_di, v_dj])
                                T.writes(DepthwiseConv2d_local[v_b, v_c, v_i, v_j])
                                T.block_attr({"meta_schedule.thread_extent_high_inclusive": 1024, "meta_schedule.thread_extent_low_inclusive": 32, "meta_schedule.tiling_structure": "SSSRRSRS"})
                                DepthwiseConv2d_local[v_b, v_c, v_i, v_j] = DepthwiseConv2d_local[v_b, v_c, v_i, v_j] + PaddedInput_shared[v_b, v_c, v_i + v_di, v_j + v_dj] * p1_shared[v_c, T.int64(0), v_di, v_dj]
                    for ax0, ax1, ax2, ax3 in T.grid(T.int64(1), T.int64(1), T.int64(1), T.int64(1)):
                        with T.block("DepthwiseConv2d_local"):
                            v0 = T.axis.spatial(T.int64(1), ax0)
                            v1 = T.axis.spatial(T.int64(116), b_1_c_1_i_1_j_1_fused // T.int64(2) * T.int64(29) + b_2_c_2_i_2_j_2_fused // T.int64(2) + ax1)
                            v2 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused // T.int64(7) * T.int64(2) + b_2_c_2_i_2_j_2_fused % T.int64(2) + ax2)
                            v3 = T.axis.spatial(T.int64(14), b_0_c_0_i_0_j_0_fused % T.int64(7) * T.int64(2) + b_1_c_1_i_1_j_1_fused % T.int64(2) + ax3)
                            T.reads(DepthwiseConv2d_local[v0, v1, v2, v3], p2[v0, v1, T.int64(0), T.int64(0)])
                            T.writes(T_add[v0, v1, v2, v3])
                            T_add[v0, v1, v2, v3] = DepthwiseConv2d_local[v0, v1, v2, v3] + p2[v0, v1, T.int64(0), T.int64(0)]
b0 = sch.get_block(name="PaddedInput", func_name="main")
b1 = sch.get_block(name="DepthwiseConv2d", func_name="main")
b2 = sch.get_block(name="T_add", func_name="main")
b3 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.tiling_structure", ann_val="SSSRRSRS")
l4, l5, l6, l7, l8, l9 = sch.get_loops(block=b1)
v10, v11, v12, v13, v14 = sch.sample_perfect_tile(loop=l4, n=5, max_innermost_factor=64, decision=[1, 1, 1, 1, 1])
l15, l16, l17, l18, l19 = sch.split(loop=l4, factors=[v10, v11, v12, v13, v14], preserve_unit_iters=True)
v20, v21, v22, v23, v24 = sch.sample_perfect_tile(loop=l5, n=5, max_innermost_factor=64, decision=[1, 4, 29, 1, 1])
l25, l26, l27, l28, l29 = sch.split(loop=l5, factors=[v20, v21, v22, v23, v24], preserve_unit_iters=True)
v30, v31, v32, v33, v34 = sch.sample_perfect_tile(loop=l6, n=5, max_innermost_factor=64, decision=[7, 1, 2, 1, 1])
l35, l36, l37, l38, l39 = sch.split(loop=l6, factors=[v30, v31, v32, v33, v34], preserve_unit_iters=True)
v40, v41, v42, v43, v44 = sch.sample_perfect_tile(loop=l7, n=5, max_innermost_factor=64, decision=[7, 2, 1, 1, 1])
l45, l46, l47, l48, l49 = sch.split(loop=l7, factors=[v40, v41, v42, v43, v44], preserve_unit_iters=True)
v50, v51, v52 = sch.sample_perfect_tile(loop=l8, n=3, max_innermost_factor=64, decision=[3, 1, 1])
l53, l54, l55 = sch.split(loop=l8, factors=[v50, v51, v52], preserve_unit_iters=True)
v56, v57, v58 = sch.sample_perfect_tile(loop=l9, n=3, max_innermost_factor=64, decision=[1, 3, 1])
l59, l60, l61 = sch.split(loop=l9, factors=[v56, v57, v58], preserve_unit_iters=True)
sch.reorder(l15, l25, l35, l45, l16, l26, l36, l46, l17, l27, l37, l47, l53, l59, l54, l60, l18, l28, l38, l48, l55, l61, l19, l29, l39, l49)
l62 = sch.fuse(l15, l25, l35, l45, preserve_unit_iters=True)
sch.bind(loop=l62, thread_axis="blockIdx.x")
l63 = sch.fuse(l16, l26, l36, l46, preserve_unit_iters=True)
sch.bind(loop=l63, thread_axis="vthread.x")
l64 = sch.fuse(l17, l27, l37, l47, preserve_unit_iters=True)
sch.bind(loop=l64, thread_axis="threadIdx.x")
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_low_inclusive", ann_val=32)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.thread_extent_high_inclusive", ann_val=1024)
b65 = sch.cache_write(block=b1, write_buffer_index=0, storage_scope="local")
sch.reverse_compute_at(block=b65, loop=l64, preserve_unit_loops=True, index=-1)
b66 = sch.cache_read(block=b1, read_buffer_index=0, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b66, loop=l59, preserve_unit_loops=True, index=-1)
l67, l68, l69, l70, l71, l72, l73, l74, l75 = sch.get_loops(block=b66)
l76 = sch.fuse(l72, l73, l74, l75, preserve_unit_iters=True)
v77 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch", ann_val=v77)
b78 = sch.cache_read(block=b1, read_buffer_index=1, storage_scope="shared", consumer_blocks=[b1])
sch.compute_at(block=b78, loop=l59, preserve_unit_loops=True, index=-1)
l79, l80, l81, l82, l83, l84, l85, l86, l87 = sch.get_loops(block=b78)
l88 = sch.fuse(l84, l85, l86, l87, preserve_unit_iters=True)
v89 = sch.sample_categorical(candidates=[1, 2, 3, 4], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch", ann_val=v89)
l90 = sch.fuse(l53, l59, preserve_unit_iters=True)
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_stage", ann_val=[0, 0, 3])
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_order", ann_val=[0, 1, 2])
sch.annotate(block_or_loop=l90, ann_key="software_pipeline_async_stages", ann_val=[0])
sch.reverse_compute_inline(block=b2)
sch.compute_inline(block=b0)
v91 = sch.sample_categorical(candidates=[0, 16, 64, 512, 1024], probs=[0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001, 0.20000000000000001], decision=4)
sch.annotate(block_or_loop=b3, ann_key="meta_schedule.unroll_explicit", ann_val=v91)
sch.enter_postproc()
sch.unannotate(block_or_loop=b66, ann_key="meta_schedule.cooperative_fetch")
l92, l93, l94, l95, l96 = sch.get_loops(block=b66)
l97, l98, l99 = sch.split(loop=l96, factors=[None, 58, 2], preserve_unit_iters=True)
sch.vectorize(loop=l99)
sch.bind(loop=l98, thread_axis="threadIdx.x")
sch.unannotate(block_or_loop=b78, ann_key="meta_schedule.cooperative_fetch")
l100, l101, l102, l103, l104 = sch.get_loops(block=b78)
l105, l106, l107 = sch.split(loop=l104, factors=[None, 58, 2], preserve_unit_iters=True)
sch.vectorize(loop=l107)
sch.bind(loop=l106, thread_axis="threadIdx.x")
b108 = sch.get_block(name="root", func_name="main")
sch.unannotate(block_or_loop=b108, ann_key="meta_schedule.unroll_explicit")
b109, b110, b111, b112 = sch.get_child_blocks(b108)
l113, l114, l115, l116, l117, l118, l119 = sch.get_loops(block=b109)
l120, l121, l122, l123, l124, l125, l126 = sch.get_loops(block=b110)
l127, l128, l129, l130, l131, l132, l133, l134, l135, l136, l137, l138, l139, l140, l141, l142 = sch.get_loops(block=b111)
sch.annotate(block_or_loop=l127, ann_key="pragma_auto_unroll_max_step", ann_val=1024)
sch.annotate(block_or_loop=l127, ann_key="pragma_unroll_explicit", ann_val=1)
l143, l144, l145, l146, l147, l148, l149 = sch.get_loops(block=b112)
b150 = sch.get_block(name="DepthwiseConv2d", func_name="main")
l151, l152, l153, l154, l155, l156, l157, l158, l159, l160, l161, l162, l163, l164, l165, l166 = sch.get_loops(block=b150)
b167 = sch.decompose_reduction(block=b150, loop=l154)
2024-04-28 23:36:34 [INFO] [evolutionary_search.cc:713] Generating candidates......
2024-04-28 23:36:35 [INFO] [evolutionary_search.cc:715] Picked top 102 candidate(s) from database
2024-04-28 23:36:37 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 398 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:36:39 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 785 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:36:41 [INFO] [evolutionary_search.cc:533] Sample-Init-Population summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 1175 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:36:41 [INFO] [evolutionary_search.cc:723] Sampled 55 candidate(s)
2024-04-28 23:36:48 [INFO] [evolutionary_search.cc:621] Evolve iter #0 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 103 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:36:57 [INFO] [evolutionary_search.cc:621] Evolve iter #1 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 121 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:37:05 [INFO] [evolutionary_search.cc:621] Evolve iter #2 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 122 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:37:14 [INFO] [evolutionary_search.cc:621] Evolve iter #3 done. Summary:
Postproc #0 [meta_schedule.DisallowDynamicLoop(0x3622348)]: 0 failure(s)
Postproc #1 [meta_schedule.RewriteCooperativeFetch(0x4dc6fd8)]: 0 failure(s)
Postproc #2 [meta_schedule.RewriteUnboundBlock(0x4d48e98)]: 0 failure(s)
Postproc #3 [meta_schedule.RewriteParallelVectorizeUnroll(0x32e9d88)]: 0 failure(s)
Postproc #4 [meta_schedule.RewriteReductionBlock(0x370c368)]: 0 failure(s)
Postproc #5 [meta_schedule.VerifyGPUCode(0x4ccee48)]: 97 failure(s)
Postproc #6 [meta_schedule.RewriteTensorize(0x4d47ad8)]: 0 failure(s)
2024-04-28 23:37:18 [INFO] [evolutionary_search.cc:649] Scores of the best 64 candidates:
[1 : 16]:	0.9879  0.9848  0.9827  0.9777  0.9772  0.9764  0.9750  0.9722  0.9722  0.9719  0.9718  0.9708  0.9702  0.9698  0.9698  0.9697
[17 : 32]:	0.9697  0.9689  0.9685  0.9679  0.9677  0.9673  0.9673  0.9672  0.9668  0.9664  0.9660  0.9660  0.9652  0.9652  0.9648  0.9648
[33 : 48]:	0.9639  0.9639  0.9626  0.9610  0.9610  0.9608  0.9600  0.9591  0.9527  0.9505  0.9505  0.9505  0.9496  0.9463  0.9463  0.9463
[49 : 64]:	0.9463  0.9461  0.9461  0.9461  0.9461  0.9451  0.9447  0.9443  0.9438  0.9438  0.9434  0.9434  0.9433  0.9433  0.9430  0.9426
2024-04-28 23:37:18 [INFO] [evolutionary_search.cc:727] Got 64 candidate(s) with evolutionary search
2024-04-28 23:37:18 [INFO] [evolutionary_search.cc:730] Sending 64 candidates(s) for measurement
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #832: GFLOPs: 140.2859. Time: 3.0793 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #833: GFLOPs: 140.4314. Time: 3.0761 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #834: GFLOPs: 140.0251. Time: 3.0850 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #835: GFLOPs: 140.7140. Time: 3.0699 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #836: GFLOPs: 140.6005. Time: 3.0724 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #837: GFLOPs: 142.0391. Time: 3.0413 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #838: GFLOPs: 140.7598. Time: 3.0689 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #839: GFLOPs: 140.2696. Time: 3.0797 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #840: GFLOPs: 140.3297. Time: 3.0784 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #841: GFLOPs: 140.5576. Time: 3.0734 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #842: GFLOPs: 140.7910. Time: 3.0683 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #843: GFLOPs: 139.8399. Time: 3.0891 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #844: GFLOPs: 139.8080. Time: 3.0898 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #845: GFLOPs: 140.8356. Time: 3.0673 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #846: GFLOPs: 140.7373. Time: 3.0694 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #847: GFLOPs: 140.6584. Time: 3.0712 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #848: GFLOPs: 140.0756. Time: 3.0839 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #849: GFLOPs: 140.1033. Time: 3.0833 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #850: GFLOPs: 139.5539. Time: 3.0955 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #851: GFLOPs: 140.7818. Time: 3.0685 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #852: GFLOPs: 138.5479. Time: 3.1179 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #853: GFLOPs: 140.2635. Time: 3.0798 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #854: GFLOPs: 140.2154. Time: 3.0809 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #855: GFLOPs: 140.3607. Time: 3.0777 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #856: GFLOPs: 139.8963. Time: 3.0879 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #857: GFLOPs: 140.7099. Time: 3.0700 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #858: GFLOPs: 140.4071. Time: 3.0767 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #859: GFLOPs: 138.4727. Time: 3.1196 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #860: GFLOPs: 140.5658. Time: 3.0732 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #861: GFLOPs: 138.6026. Time: 3.1167 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #862: GFLOPs: 139.8369. Time: 3.0892 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #863: GFLOPs: 139.6750. Time: 3.0928 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #864: GFLOPs: 139.8478. Time: 3.0890 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #865: GFLOPs: 140.2749. Time: 3.0796 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #866: GFLOPs: 140.3214. Time: 3.0785 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #867: GFLOPs: 140.7187. Time: 3.0698 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #868: GFLOPs: 140.7575. Time: 3.0690 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #869: GFLOPs: 139.7867. Time: 3.0903 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #870: GFLOPs: 140.3632. Time: 3.0776 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #871: GFLOPs: 139.7316. Time: 3.0915 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #872: GFLOPs: 140.7536. Time: 3.0691 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #873: GFLOPs: 140.1266. Time: 3.0828 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #874: GFLOPs: 140.1458. Time: 3.0824 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #875: GFLOPs: 140.0720. Time: 3.0840 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #876: GFLOPs: 140.8567. Time: 3.0668 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #877: GFLOPs: 139.8731. Time: 3.0884 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #878: GFLOPs: 139.8400. Time: 3.0891 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #879: GFLOPs: 139.8846. Time: 3.0881 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #880: GFLOPs: 139.8235. Time: 3.0895 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #881: GFLOPs: 139.2766. Time: 3.1016 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #882: GFLOPs: 139.9011. Time: 3.0878 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #883: GFLOPs: 140.0879. Time: 3.0837 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #884: GFLOPs: 138.2635. Time: 3.1244 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #885: GFLOPs: 139.7393. Time: 3.0914 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #886: GFLOPs: 130.9291. Time: 3.2994 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #887: GFLOPs: 114.4927. Time: 3.7730 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #888: GFLOPs: 140.4965. Time: 3.0747 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #889: GFLOPs: 140.7570. Time: 3.0690 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #890: GFLOPs: 139.3873. Time: 3.0992 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #891: GFLOPs: 139.5413. Time: 3.0957 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #892: GFLOPs: 139.4137. Time: 3.0986 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #893: GFLOPs: 59.5974. Time: 7.2484 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #894: GFLOPs: 83.8091. Time: 5.1544 us. Best GFLOPs: 148.0037
2024-04-28 23:38:18 [INFO] [task_scheduler.cc:131] [Task #4: fused_nn_conv2d_add_1] Trial #895: GFLOPs: 83.9647. Time: 5.1448 us. Best GFLOPs: 148.0037
